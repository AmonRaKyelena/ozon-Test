// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i ozon-test-project/internal/service/post.PostService -o post_service_mock.go -n PostServiceMock -p mocks

import (
	"context"
	"ozon-test-project/internal/handlers/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// PostServiceMock implements mm_post.PostService
type PostServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreatePost          func(ctx context.Context, newPost model.NewPost) (i1 int64, err error)
	funcCreatePostOrigin    string
	inspectFuncCreatePost   func(ctx context.Context, newPost model.NewPost)
	afterCreatePostCounter  uint64
	beforeCreatePostCounter uint64
	CreatePostMock          mPostServiceMockCreatePost

	funcGetAllPosts          func(ctx context.Context, limit int32, offset int32) (pa1 []model.PostForPagination, err error)
	funcGetAllPostsOrigin    string
	inspectFuncGetAllPosts   func(ctx context.Context, limit int32, offset int32)
	afterGetAllPostsCounter  uint64
	beforeGetAllPostsCounter uint64
	GetAllPostsMock          mPostServiceMockGetAllPosts

	funcGetPostByID          func(ctx context.Context, id int64) (pp1 *model.PostForPagination, err error)
	funcGetPostByIDOrigin    string
	inspectFuncGetPostByID   func(ctx context.Context, id int64)
	afterGetPostByIDCounter  uint64
	beforeGetPostByIDCounter uint64
	GetPostByIDMock          mPostServiceMockGetPostByID
}

// NewPostServiceMock returns a mock for mm_post.PostService
func NewPostServiceMock(t minimock.Tester) *PostServiceMock {
	m := &PostServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreatePostMock = mPostServiceMockCreatePost{mock: m}
	m.CreatePostMock.callArgs = []*PostServiceMockCreatePostParams{}

	m.GetAllPostsMock = mPostServiceMockGetAllPosts{mock: m}
	m.GetAllPostsMock.callArgs = []*PostServiceMockGetAllPostsParams{}

	m.GetPostByIDMock = mPostServiceMockGetPostByID{mock: m}
	m.GetPostByIDMock.callArgs = []*PostServiceMockGetPostByIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPostServiceMockCreatePost struct {
	optional           bool
	mock               *PostServiceMock
	defaultExpectation *PostServiceMockCreatePostExpectation
	expectations       []*PostServiceMockCreatePostExpectation

	callArgs []*PostServiceMockCreatePostParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostServiceMockCreatePostExpectation specifies expectation struct of the PostService.CreatePost
type PostServiceMockCreatePostExpectation struct {
	mock               *PostServiceMock
	params             *PostServiceMockCreatePostParams
	paramPtrs          *PostServiceMockCreatePostParamPtrs
	expectationOrigins PostServiceMockCreatePostExpectationOrigins
	results            *PostServiceMockCreatePostResults
	returnOrigin       string
	Counter            uint64
}

// PostServiceMockCreatePostParams contains parameters of the PostService.CreatePost
type PostServiceMockCreatePostParams struct {
	ctx     context.Context
	newPost model.NewPost
}

// PostServiceMockCreatePostParamPtrs contains pointers to parameters of the PostService.CreatePost
type PostServiceMockCreatePostParamPtrs struct {
	ctx     *context.Context
	newPost *model.NewPost
}

// PostServiceMockCreatePostResults contains results of the PostService.CreatePost
type PostServiceMockCreatePostResults struct {
	i1  int64
	err error
}

// PostServiceMockCreatePostOrigins contains origins of expectations of the PostService.CreatePost
type PostServiceMockCreatePostExpectationOrigins struct {
	origin        string
	originCtx     string
	originNewPost string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePost *mPostServiceMockCreatePost) Optional() *mPostServiceMockCreatePost {
	mmCreatePost.optional = true
	return mmCreatePost
}

// Expect sets up expected params for PostService.CreatePost
func (mmCreatePost *mPostServiceMockCreatePost) Expect(ctx context.Context, newPost model.NewPost) *mPostServiceMockCreatePost {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("PostServiceMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &PostServiceMockCreatePostExpectation{}
	}

	if mmCreatePost.defaultExpectation.paramPtrs != nil {
		mmCreatePost.mock.t.Fatalf("PostServiceMock.CreatePost mock is already set by ExpectParams functions")
	}

	mmCreatePost.defaultExpectation.params = &PostServiceMockCreatePostParams{ctx, newPost}
	mmCreatePost.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePost.expectations {
		if minimock.Equal(e.params, mmCreatePost.defaultExpectation.params) {
			mmCreatePost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePost.defaultExpectation.params)
		}
	}

	return mmCreatePost
}

// ExpectCtxParam1 sets up expected param ctx for PostService.CreatePost
func (mmCreatePost *mPostServiceMockCreatePost) ExpectCtxParam1(ctx context.Context) *mPostServiceMockCreatePost {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("PostServiceMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &PostServiceMockCreatePostExpectation{}
	}

	if mmCreatePost.defaultExpectation.params != nil {
		mmCreatePost.mock.t.Fatalf("PostServiceMock.CreatePost mock is already set by Expect")
	}

	if mmCreatePost.defaultExpectation.paramPtrs == nil {
		mmCreatePost.defaultExpectation.paramPtrs = &PostServiceMockCreatePostParamPtrs{}
	}
	mmCreatePost.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePost.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePost
}

// ExpectNewPostParam2 sets up expected param newPost for PostService.CreatePost
func (mmCreatePost *mPostServiceMockCreatePost) ExpectNewPostParam2(newPost model.NewPost) *mPostServiceMockCreatePost {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("PostServiceMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &PostServiceMockCreatePostExpectation{}
	}

	if mmCreatePost.defaultExpectation.params != nil {
		mmCreatePost.mock.t.Fatalf("PostServiceMock.CreatePost mock is already set by Expect")
	}

	if mmCreatePost.defaultExpectation.paramPtrs == nil {
		mmCreatePost.defaultExpectation.paramPtrs = &PostServiceMockCreatePostParamPtrs{}
	}
	mmCreatePost.defaultExpectation.paramPtrs.newPost = &newPost
	mmCreatePost.defaultExpectation.expectationOrigins.originNewPost = minimock.CallerInfo(1)

	return mmCreatePost
}

// Inspect accepts an inspector function that has same arguments as the PostService.CreatePost
func (mmCreatePost *mPostServiceMockCreatePost) Inspect(f func(ctx context.Context, newPost model.NewPost)) *mPostServiceMockCreatePost {
	if mmCreatePost.mock.inspectFuncCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("Inspect function is already set for PostServiceMock.CreatePost")
	}

	mmCreatePost.mock.inspectFuncCreatePost = f

	return mmCreatePost
}

// Return sets up results that will be returned by PostService.CreatePost
func (mmCreatePost *mPostServiceMockCreatePost) Return(i1 int64, err error) *PostServiceMock {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("PostServiceMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &PostServiceMockCreatePostExpectation{mock: mmCreatePost.mock}
	}
	mmCreatePost.defaultExpectation.results = &PostServiceMockCreatePostResults{i1, err}
	mmCreatePost.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePost.mock
}

// Set uses given function f to mock the PostService.CreatePost method
func (mmCreatePost *mPostServiceMockCreatePost) Set(f func(ctx context.Context, newPost model.NewPost) (i1 int64, err error)) *PostServiceMock {
	if mmCreatePost.defaultExpectation != nil {
		mmCreatePost.mock.t.Fatalf("Default expectation is already set for the PostService.CreatePost method")
	}

	if len(mmCreatePost.expectations) > 0 {
		mmCreatePost.mock.t.Fatalf("Some expectations are already set for the PostService.CreatePost method")
	}

	mmCreatePost.mock.funcCreatePost = f
	mmCreatePost.mock.funcCreatePostOrigin = minimock.CallerInfo(1)
	return mmCreatePost.mock
}

// When sets expectation for the PostService.CreatePost which will trigger the result defined by the following
// Then helper
func (mmCreatePost *mPostServiceMockCreatePost) When(ctx context.Context, newPost model.NewPost) *PostServiceMockCreatePostExpectation {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("PostServiceMock.CreatePost mock is already set by Set")
	}

	expectation := &PostServiceMockCreatePostExpectation{
		mock:               mmCreatePost.mock,
		params:             &PostServiceMockCreatePostParams{ctx, newPost},
		expectationOrigins: PostServiceMockCreatePostExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePost.expectations = append(mmCreatePost.expectations, expectation)
	return expectation
}

// Then sets up PostService.CreatePost return parameters for the expectation previously defined by the When method
func (e *PostServiceMockCreatePostExpectation) Then(i1 int64, err error) *PostServiceMock {
	e.results = &PostServiceMockCreatePostResults{i1, err}
	return e.mock
}

// Times sets number of times PostService.CreatePost should be invoked
func (mmCreatePost *mPostServiceMockCreatePost) Times(n uint64) *mPostServiceMockCreatePost {
	if n == 0 {
		mmCreatePost.mock.t.Fatalf("Times of PostServiceMock.CreatePost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePost.expectedInvocations, n)
	mmCreatePost.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePost
}

func (mmCreatePost *mPostServiceMockCreatePost) invocationsDone() bool {
	if len(mmCreatePost.expectations) == 0 && mmCreatePost.defaultExpectation == nil && mmCreatePost.mock.funcCreatePost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePost.mock.afterCreatePostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePost implements mm_post.PostService
func (mmCreatePost *PostServiceMock) CreatePost(ctx context.Context, newPost model.NewPost) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreatePost.beforeCreatePostCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePost.afterCreatePostCounter, 1)

	mmCreatePost.t.Helper()

	if mmCreatePost.inspectFuncCreatePost != nil {
		mmCreatePost.inspectFuncCreatePost(ctx, newPost)
	}

	mm_params := PostServiceMockCreatePostParams{ctx, newPost}

	// Record call args
	mmCreatePost.CreatePostMock.mutex.Lock()
	mmCreatePost.CreatePostMock.callArgs = append(mmCreatePost.CreatePostMock.callArgs, &mm_params)
	mmCreatePost.CreatePostMock.mutex.Unlock()

	for _, e := range mmCreatePost.CreatePostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreatePost.CreatePostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePost.CreatePostMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePost.CreatePostMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePost.CreatePostMock.defaultExpectation.paramPtrs

		mm_got := PostServiceMockCreatePostParams{ctx, newPost}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePost.t.Errorf("PostServiceMock.CreatePost got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePost.CreatePostMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.newPost != nil && !minimock.Equal(*mm_want_ptrs.newPost, mm_got.newPost) {
				mmCreatePost.t.Errorf("PostServiceMock.CreatePost got unexpected parameter newPost, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePost.CreatePostMock.defaultExpectation.expectationOrigins.originNewPost, *mm_want_ptrs.newPost, mm_got.newPost, minimock.Diff(*mm_want_ptrs.newPost, mm_got.newPost))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePost.t.Errorf("PostServiceMock.CreatePost got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePost.CreatePostMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePost.CreatePostMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePost.t.Fatal("No results are set for the PostServiceMock.CreatePost")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreatePost.funcCreatePost != nil {
		return mmCreatePost.funcCreatePost(ctx, newPost)
	}
	mmCreatePost.t.Fatalf("Unexpected call to PostServiceMock.CreatePost. %v %v", ctx, newPost)
	return
}

// CreatePostAfterCounter returns a count of finished PostServiceMock.CreatePost invocations
func (mmCreatePost *PostServiceMock) CreatePostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePost.afterCreatePostCounter)
}

// CreatePostBeforeCounter returns a count of PostServiceMock.CreatePost invocations
func (mmCreatePost *PostServiceMock) CreatePostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePost.beforeCreatePostCounter)
}

// Calls returns a list of arguments used in each call to PostServiceMock.CreatePost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePost *mPostServiceMockCreatePost) Calls() []*PostServiceMockCreatePostParams {
	mmCreatePost.mutex.RLock()

	argCopy := make([]*PostServiceMockCreatePostParams, len(mmCreatePost.callArgs))
	copy(argCopy, mmCreatePost.callArgs)

	mmCreatePost.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePostDone returns true if the count of the CreatePost invocations corresponds
// the number of defined expectations
func (m *PostServiceMock) MinimockCreatePostDone() bool {
	if m.CreatePostMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePostMock.invocationsDone()
}

// MinimockCreatePostInspect logs each unmet expectation
func (m *PostServiceMock) MinimockCreatePostInspect() {
	for _, e := range m.CreatePostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostServiceMock.CreatePost at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePostCounter := mm_atomic.LoadUint64(&m.afterCreatePostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePostMock.defaultExpectation != nil && afterCreatePostCounter < 1 {
		if m.CreatePostMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostServiceMock.CreatePost at\n%s", m.CreatePostMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostServiceMock.CreatePost at\n%s with params: %#v", m.CreatePostMock.defaultExpectation.expectationOrigins.origin, *m.CreatePostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePost != nil && afterCreatePostCounter < 1 {
		m.t.Errorf("Expected call to PostServiceMock.CreatePost at\n%s", m.funcCreatePostOrigin)
	}

	if !m.CreatePostMock.invocationsDone() && afterCreatePostCounter > 0 {
		m.t.Errorf("Expected %d calls to PostServiceMock.CreatePost at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePostMock.expectedInvocations), m.CreatePostMock.expectedInvocationsOrigin, afterCreatePostCounter)
	}
}

type mPostServiceMockGetAllPosts struct {
	optional           bool
	mock               *PostServiceMock
	defaultExpectation *PostServiceMockGetAllPostsExpectation
	expectations       []*PostServiceMockGetAllPostsExpectation

	callArgs []*PostServiceMockGetAllPostsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostServiceMockGetAllPostsExpectation specifies expectation struct of the PostService.GetAllPosts
type PostServiceMockGetAllPostsExpectation struct {
	mock               *PostServiceMock
	params             *PostServiceMockGetAllPostsParams
	paramPtrs          *PostServiceMockGetAllPostsParamPtrs
	expectationOrigins PostServiceMockGetAllPostsExpectationOrigins
	results            *PostServiceMockGetAllPostsResults
	returnOrigin       string
	Counter            uint64
}

// PostServiceMockGetAllPostsParams contains parameters of the PostService.GetAllPosts
type PostServiceMockGetAllPostsParams struct {
	ctx    context.Context
	limit  int32
	offset int32
}

// PostServiceMockGetAllPostsParamPtrs contains pointers to parameters of the PostService.GetAllPosts
type PostServiceMockGetAllPostsParamPtrs struct {
	ctx    *context.Context
	limit  *int32
	offset *int32
}

// PostServiceMockGetAllPostsResults contains results of the PostService.GetAllPosts
type PostServiceMockGetAllPostsResults struct {
	pa1 []model.PostForPagination
	err error
}

// PostServiceMockGetAllPostsOrigins contains origins of expectations of the PostService.GetAllPosts
type PostServiceMockGetAllPostsExpectationOrigins struct {
	origin       string
	originCtx    string
	originLimit  string
	originOffset string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllPosts *mPostServiceMockGetAllPosts) Optional() *mPostServiceMockGetAllPosts {
	mmGetAllPosts.optional = true
	return mmGetAllPosts
}

// Expect sets up expected params for PostService.GetAllPosts
func (mmGetAllPosts *mPostServiceMockGetAllPosts) Expect(ctx context.Context, limit int32, offset int32) *mPostServiceMockGetAllPosts {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("PostServiceMock.GetAllPosts mock is already set by Set")
	}

	if mmGetAllPosts.defaultExpectation == nil {
		mmGetAllPosts.defaultExpectation = &PostServiceMockGetAllPostsExpectation{}
	}

	if mmGetAllPosts.defaultExpectation.paramPtrs != nil {
		mmGetAllPosts.mock.t.Fatalf("PostServiceMock.GetAllPosts mock is already set by ExpectParams functions")
	}

	mmGetAllPosts.defaultExpectation.params = &PostServiceMockGetAllPostsParams{ctx, limit, offset}
	mmGetAllPosts.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAllPosts.expectations {
		if minimock.Equal(e.params, mmGetAllPosts.defaultExpectation.params) {
			mmGetAllPosts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllPosts.defaultExpectation.params)
		}
	}

	return mmGetAllPosts
}

// ExpectCtxParam1 sets up expected param ctx for PostService.GetAllPosts
func (mmGetAllPosts *mPostServiceMockGetAllPosts) ExpectCtxParam1(ctx context.Context) *mPostServiceMockGetAllPosts {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("PostServiceMock.GetAllPosts mock is already set by Set")
	}

	if mmGetAllPosts.defaultExpectation == nil {
		mmGetAllPosts.defaultExpectation = &PostServiceMockGetAllPostsExpectation{}
	}

	if mmGetAllPosts.defaultExpectation.params != nil {
		mmGetAllPosts.mock.t.Fatalf("PostServiceMock.GetAllPosts mock is already set by Expect")
	}

	if mmGetAllPosts.defaultExpectation.paramPtrs == nil {
		mmGetAllPosts.defaultExpectation.paramPtrs = &PostServiceMockGetAllPostsParamPtrs{}
	}
	mmGetAllPosts.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAllPosts.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAllPosts
}

// ExpectLimitParam2 sets up expected param limit for PostService.GetAllPosts
func (mmGetAllPosts *mPostServiceMockGetAllPosts) ExpectLimitParam2(limit int32) *mPostServiceMockGetAllPosts {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("PostServiceMock.GetAllPosts mock is already set by Set")
	}

	if mmGetAllPosts.defaultExpectation == nil {
		mmGetAllPosts.defaultExpectation = &PostServiceMockGetAllPostsExpectation{}
	}

	if mmGetAllPosts.defaultExpectation.params != nil {
		mmGetAllPosts.mock.t.Fatalf("PostServiceMock.GetAllPosts mock is already set by Expect")
	}

	if mmGetAllPosts.defaultExpectation.paramPtrs == nil {
		mmGetAllPosts.defaultExpectation.paramPtrs = &PostServiceMockGetAllPostsParamPtrs{}
	}
	mmGetAllPosts.defaultExpectation.paramPtrs.limit = &limit
	mmGetAllPosts.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetAllPosts
}

// ExpectOffsetParam3 sets up expected param offset for PostService.GetAllPosts
func (mmGetAllPosts *mPostServiceMockGetAllPosts) ExpectOffsetParam3(offset int32) *mPostServiceMockGetAllPosts {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("PostServiceMock.GetAllPosts mock is already set by Set")
	}

	if mmGetAllPosts.defaultExpectation == nil {
		mmGetAllPosts.defaultExpectation = &PostServiceMockGetAllPostsExpectation{}
	}

	if mmGetAllPosts.defaultExpectation.params != nil {
		mmGetAllPosts.mock.t.Fatalf("PostServiceMock.GetAllPosts mock is already set by Expect")
	}

	if mmGetAllPosts.defaultExpectation.paramPtrs == nil {
		mmGetAllPosts.defaultExpectation.paramPtrs = &PostServiceMockGetAllPostsParamPtrs{}
	}
	mmGetAllPosts.defaultExpectation.paramPtrs.offset = &offset
	mmGetAllPosts.defaultExpectation.expectationOrigins.originOffset = minimock.CallerInfo(1)

	return mmGetAllPosts
}

// Inspect accepts an inspector function that has same arguments as the PostService.GetAllPosts
func (mmGetAllPosts *mPostServiceMockGetAllPosts) Inspect(f func(ctx context.Context, limit int32, offset int32)) *mPostServiceMockGetAllPosts {
	if mmGetAllPosts.mock.inspectFuncGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("Inspect function is already set for PostServiceMock.GetAllPosts")
	}

	mmGetAllPosts.mock.inspectFuncGetAllPosts = f

	return mmGetAllPosts
}

// Return sets up results that will be returned by PostService.GetAllPosts
func (mmGetAllPosts *mPostServiceMockGetAllPosts) Return(pa1 []model.PostForPagination, err error) *PostServiceMock {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("PostServiceMock.GetAllPosts mock is already set by Set")
	}

	if mmGetAllPosts.defaultExpectation == nil {
		mmGetAllPosts.defaultExpectation = &PostServiceMockGetAllPostsExpectation{mock: mmGetAllPosts.mock}
	}
	mmGetAllPosts.defaultExpectation.results = &PostServiceMockGetAllPostsResults{pa1, err}
	mmGetAllPosts.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAllPosts.mock
}

// Set uses given function f to mock the PostService.GetAllPosts method
func (mmGetAllPosts *mPostServiceMockGetAllPosts) Set(f func(ctx context.Context, limit int32, offset int32) (pa1 []model.PostForPagination, err error)) *PostServiceMock {
	if mmGetAllPosts.defaultExpectation != nil {
		mmGetAllPosts.mock.t.Fatalf("Default expectation is already set for the PostService.GetAllPosts method")
	}

	if len(mmGetAllPosts.expectations) > 0 {
		mmGetAllPosts.mock.t.Fatalf("Some expectations are already set for the PostService.GetAllPosts method")
	}

	mmGetAllPosts.mock.funcGetAllPosts = f
	mmGetAllPosts.mock.funcGetAllPostsOrigin = minimock.CallerInfo(1)
	return mmGetAllPosts.mock
}

// When sets expectation for the PostService.GetAllPosts which will trigger the result defined by the following
// Then helper
func (mmGetAllPosts *mPostServiceMockGetAllPosts) When(ctx context.Context, limit int32, offset int32) *PostServiceMockGetAllPostsExpectation {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("PostServiceMock.GetAllPosts mock is already set by Set")
	}

	expectation := &PostServiceMockGetAllPostsExpectation{
		mock:               mmGetAllPosts.mock,
		params:             &PostServiceMockGetAllPostsParams{ctx, limit, offset},
		expectationOrigins: PostServiceMockGetAllPostsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAllPosts.expectations = append(mmGetAllPosts.expectations, expectation)
	return expectation
}

// Then sets up PostService.GetAllPosts return parameters for the expectation previously defined by the When method
func (e *PostServiceMockGetAllPostsExpectation) Then(pa1 []model.PostForPagination, err error) *PostServiceMock {
	e.results = &PostServiceMockGetAllPostsResults{pa1, err}
	return e.mock
}

// Times sets number of times PostService.GetAllPosts should be invoked
func (mmGetAllPosts *mPostServiceMockGetAllPosts) Times(n uint64) *mPostServiceMockGetAllPosts {
	if n == 0 {
		mmGetAllPosts.mock.t.Fatalf("Times of PostServiceMock.GetAllPosts mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllPosts.expectedInvocations, n)
	mmGetAllPosts.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAllPosts
}

func (mmGetAllPosts *mPostServiceMockGetAllPosts) invocationsDone() bool {
	if len(mmGetAllPosts.expectations) == 0 && mmGetAllPosts.defaultExpectation == nil && mmGetAllPosts.mock.funcGetAllPosts == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllPosts.mock.afterGetAllPostsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllPosts.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllPosts implements mm_post.PostService
func (mmGetAllPosts *PostServiceMock) GetAllPosts(ctx context.Context, limit int32, offset int32) (pa1 []model.PostForPagination, err error) {
	mm_atomic.AddUint64(&mmGetAllPosts.beforeGetAllPostsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllPosts.afterGetAllPostsCounter, 1)

	mmGetAllPosts.t.Helper()

	if mmGetAllPosts.inspectFuncGetAllPosts != nil {
		mmGetAllPosts.inspectFuncGetAllPosts(ctx, limit, offset)
	}

	mm_params := PostServiceMockGetAllPostsParams{ctx, limit, offset}

	// Record call args
	mmGetAllPosts.GetAllPostsMock.mutex.Lock()
	mmGetAllPosts.GetAllPostsMock.callArgs = append(mmGetAllPosts.GetAllPostsMock.callArgs, &mm_params)
	mmGetAllPosts.GetAllPostsMock.mutex.Unlock()

	for _, e := range mmGetAllPosts.GetAllPostsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetAllPosts.GetAllPostsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllPosts.GetAllPostsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllPosts.GetAllPostsMock.defaultExpectation.params
		mm_want_ptrs := mmGetAllPosts.GetAllPostsMock.defaultExpectation.paramPtrs

		mm_got := PostServiceMockGetAllPostsParams{ctx, limit, offset}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAllPosts.t.Errorf("PostServiceMock.GetAllPosts got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllPosts.GetAllPostsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetAllPosts.t.Errorf("PostServiceMock.GetAllPosts got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllPosts.GetAllPostsMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmGetAllPosts.t.Errorf("PostServiceMock.GetAllPosts got unexpected parameter offset, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllPosts.GetAllPostsMock.defaultExpectation.expectationOrigins.originOffset, *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllPosts.t.Errorf("PostServiceMock.GetAllPosts got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAllPosts.GetAllPostsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllPosts.GetAllPostsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllPosts.t.Fatal("No results are set for the PostServiceMock.GetAllPosts")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetAllPosts.funcGetAllPosts != nil {
		return mmGetAllPosts.funcGetAllPosts(ctx, limit, offset)
	}
	mmGetAllPosts.t.Fatalf("Unexpected call to PostServiceMock.GetAllPosts. %v %v %v", ctx, limit, offset)
	return
}

// GetAllPostsAfterCounter returns a count of finished PostServiceMock.GetAllPosts invocations
func (mmGetAllPosts *PostServiceMock) GetAllPostsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllPosts.afterGetAllPostsCounter)
}

// GetAllPostsBeforeCounter returns a count of PostServiceMock.GetAllPosts invocations
func (mmGetAllPosts *PostServiceMock) GetAllPostsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllPosts.beforeGetAllPostsCounter)
}

// Calls returns a list of arguments used in each call to PostServiceMock.GetAllPosts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllPosts *mPostServiceMockGetAllPosts) Calls() []*PostServiceMockGetAllPostsParams {
	mmGetAllPosts.mutex.RLock()

	argCopy := make([]*PostServiceMockGetAllPostsParams, len(mmGetAllPosts.callArgs))
	copy(argCopy, mmGetAllPosts.callArgs)

	mmGetAllPosts.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllPostsDone returns true if the count of the GetAllPosts invocations corresponds
// the number of defined expectations
func (m *PostServiceMock) MinimockGetAllPostsDone() bool {
	if m.GetAllPostsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllPostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllPostsMock.invocationsDone()
}

// MinimockGetAllPostsInspect logs each unmet expectation
func (m *PostServiceMock) MinimockGetAllPostsInspect() {
	for _, e := range m.GetAllPostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostServiceMock.GetAllPosts at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllPostsCounter := mm_atomic.LoadUint64(&m.afterGetAllPostsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllPostsMock.defaultExpectation != nil && afterGetAllPostsCounter < 1 {
		if m.GetAllPostsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostServiceMock.GetAllPosts at\n%s", m.GetAllPostsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostServiceMock.GetAllPosts at\n%s with params: %#v", m.GetAllPostsMock.defaultExpectation.expectationOrigins.origin, *m.GetAllPostsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllPosts != nil && afterGetAllPostsCounter < 1 {
		m.t.Errorf("Expected call to PostServiceMock.GetAllPosts at\n%s", m.funcGetAllPostsOrigin)
	}

	if !m.GetAllPostsMock.invocationsDone() && afterGetAllPostsCounter > 0 {
		m.t.Errorf("Expected %d calls to PostServiceMock.GetAllPosts at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllPostsMock.expectedInvocations), m.GetAllPostsMock.expectedInvocationsOrigin, afterGetAllPostsCounter)
	}
}

type mPostServiceMockGetPostByID struct {
	optional           bool
	mock               *PostServiceMock
	defaultExpectation *PostServiceMockGetPostByIDExpectation
	expectations       []*PostServiceMockGetPostByIDExpectation

	callArgs []*PostServiceMockGetPostByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PostServiceMockGetPostByIDExpectation specifies expectation struct of the PostService.GetPostByID
type PostServiceMockGetPostByIDExpectation struct {
	mock               *PostServiceMock
	params             *PostServiceMockGetPostByIDParams
	paramPtrs          *PostServiceMockGetPostByIDParamPtrs
	expectationOrigins PostServiceMockGetPostByIDExpectationOrigins
	results            *PostServiceMockGetPostByIDResults
	returnOrigin       string
	Counter            uint64
}

// PostServiceMockGetPostByIDParams contains parameters of the PostService.GetPostByID
type PostServiceMockGetPostByIDParams struct {
	ctx context.Context
	id  int64
}

// PostServiceMockGetPostByIDParamPtrs contains pointers to parameters of the PostService.GetPostByID
type PostServiceMockGetPostByIDParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// PostServiceMockGetPostByIDResults contains results of the PostService.GetPostByID
type PostServiceMockGetPostByIDResults struct {
	pp1 *model.PostForPagination
	err error
}

// PostServiceMockGetPostByIDOrigins contains origins of expectations of the PostService.GetPostByID
type PostServiceMockGetPostByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPostByID *mPostServiceMockGetPostByID) Optional() *mPostServiceMockGetPostByID {
	mmGetPostByID.optional = true
	return mmGetPostByID
}

// Expect sets up expected params for PostService.GetPostByID
func (mmGetPostByID *mPostServiceMockGetPostByID) Expect(ctx context.Context, id int64) *mPostServiceMockGetPostByID {
	if mmGetPostByID.mock.funcGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("PostServiceMock.GetPostByID mock is already set by Set")
	}

	if mmGetPostByID.defaultExpectation == nil {
		mmGetPostByID.defaultExpectation = &PostServiceMockGetPostByIDExpectation{}
	}

	if mmGetPostByID.defaultExpectation.paramPtrs != nil {
		mmGetPostByID.mock.t.Fatalf("PostServiceMock.GetPostByID mock is already set by ExpectParams functions")
	}

	mmGetPostByID.defaultExpectation.params = &PostServiceMockGetPostByIDParams{ctx, id}
	mmGetPostByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPostByID.expectations {
		if minimock.Equal(e.params, mmGetPostByID.defaultExpectation.params) {
			mmGetPostByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPostByID.defaultExpectation.params)
		}
	}

	return mmGetPostByID
}

// ExpectCtxParam1 sets up expected param ctx for PostService.GetPostByID
func (mmGetPostByID *mPostServiceMockGetPostByID) ExpectCtxParam1(ctx context.Context) *mPostServiceMockGetPostByID {
	if mmGetPostByID.mock.funcGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("PostServiceMock.GetPostByID mock is already set by Set")
	}

	if mmGetPostByID.defaultExpectation == nil {
		mmGetPostByID.defaultExpectation = &PostServiceMockGetPostByIDExpectation{}
	}

	if mmGetPostByID.defaultExpectation.params != nil {
		mmGetPostByID.mock.t.Fatalf("PostServiceMock.GetPostByID mock is already set by Expect")
	}

	if mmGetPostByID.defaultExpectation.paramPtrs == nil {
		mmGetPostByID.defaultExpectation.paramPtrs = &PostServiceMockGetPostByIDParamPtrs{}
	}
	mmGetPostByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPostByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPostByID
}

// ExpectIdParam2 sets up expected param id for PostService.GetPostByID
func (mmGetPostByID *mPostServiceMockGetPostByID) ExpectIdParam2(id int64) *mPostServiceMockGetPostByID {
	if mmGetPostByID.mock.funcGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("PostServiceMock.GetPostByID mock is already set by Set")
	}

	if mmGetPostByID.defaultExpectation == nil {
		mmGetPostByID.defaultExpectation = &PostServiceMockGetPostByIDExpectation{}
	}

	if mmGetPostByID.defaultExpectation.params != nil {
		mmGetPostByID.mock.t.Fatalf("PostServiceMock.GetPostByID mock is already set by Expect")
	}

	if mmGetPostByID.defaultExpectation.paramPtrs == nil {
		mmGetPostByID.defaultExpectation.paramPtrs = &PostServiceMockGetPostByIDParamPtrs{}
	}
	mmGetPostByID.defaultExpectation.paramPtrs.id = &id
	mmGetPostByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetPostByID
}

// Inspect accepts an inspector function that has same arguments as the PostService.GetPostByID
func (mmGetPostByID *mPostServiceMockGetPostByID) Inspect(f func(ctx context.Context, id int64)) *mPostServiceMockGetPostByID {
	if mmGetPostByID.mock.inspectFuncGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("Inspect function is already set for PostServiceMock.GetPostByID")
	}

	mmGetPostByID.mock.inspectFuncGetPostByID = f

	return mmGetPostByID
}

// Return sets up results that will be returned by PostService.GetPostByID
func (mmGetPostByID *mPostServiceMockGetPostByID) Return(pp1 *model.PostForPagination, err error) *PostServiceMock {
	if mmGetPostByID.mock.funcGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("PostServiceMock.GetPostByID mock is already set by Set")
	}

	if mmGetPostByID.defaultExpectation == nil {
		mmGetPostByID.defaultExpectation = &PostServiceMockGetPostByIDExpectation{mock: mmGetPostByID.mock}
	}
	mmGetPostByID.defaultExpectation.results = &PostServiceMockGetPostByIDResults{pp1, err}
	mmGetPostByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPostByID.mock
}

// Set uses given function f to mock the PostService.GetPostByID method
func (mmGetPostByID *mPostServiceMockGetPostByID) Set(f func(ctx context.Context, id int64) (pp1 *model.PostForPagination, err error)) *PostServiceMock {
	if mmGetPostByID.defaultExpectation != nil {
		mmGetPostByID.mock.t.Fatalf("Default expectation is already set for the PostService.GetPostByID method")
	}

	if len(mmGetPostByID.expectations) > 0 {
		mmGetPostByID.mock.t.Fatalf("Some expectations are already set for the PostService.GetPostByID method")
	}

	mmGetPostByID.mock.funcGetPostByID = f
	mmGetPostByID.mock.funcGetPostByIDOrigin = minimock.CallerInfo(1)
	return mmGetPostByID.mock
}

// When sets expectation for the PostService.GetPostByID which will trigger the result defined by the following
// Then helper
func (mmGetPostByID *mPostServiceMockGetPostByID) When(ctx context.Context, id int64) *PostServiceMockGetPostByIDExpectation {
	if mmGetPostByID.mock.funcGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("PostServiceMock.GetPostByID mock is already set by Set")
	}

	expectation := &PostServiceMockGetPostByIDExpectation{
		mock:               mmGetPostByID.mock,
		params:             &PostServiceMockGetPostByIDParams{ctx, id},
		expectationOrigins: PostServiceMockGetPostByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPostByID.expectations = append(mmGetPostByID.expectations, expectation)
	return expectation
}

// Then sets up PostService.GetPostByID return parameters for the expectation previously defined by the When method
func (e *PostServiceMockGetPostByIDExpectation) Then(pp1 *model.PostForPagination, err error) *PostServiceMock {
	e.results = &PostServiceMockGetPostByIDResults{pp1, err}
	return e.mock
}

// Times sets number of times PostService.GetPostByID should be invoked
func (mmGetPostByID *mPostServiceMockGetPostByID) Times(n uint64) *mPostServiceMockGetPostByID {
	if n == 0 {
		mmGetPostByID.mock.t.Fatalf("Times of PostServiceMock.GetPostByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPostByID.expectedInvocations, n)
	mmGetPostByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPostByID
}

func (mmGetPostByID *mPostServiceMockGetPostByID) invocationsDone() bool {
	if len(mmGetPostByID.expectations) == 0 && mmGetPostByID.defaultExpectation == nil && mmGetPostByID.mock.funcGetPostByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPostByID.mock.afterGetPostByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPostByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPostByID implements mm_post.PostService
func (mmGetPostByID *PostServiceMock) GetPostByID(ctx context.Context, id int64) (pp1 *model.PostForPagination, err error) {
	mm_atomic.AddUint64(&mmGetPostByID.beforeGetPostByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPostByID.afterGetPostByIDCounter, 1)

	mmGetPostByID.t.Helper()

	if mmGetPostByID.inspectFuncGetPostByID != nil {
		mmGetPostByID.inspectFuncGetPostByID(ctx, id)
	}

	mm_params := PostServiceMockGetPostByIDParams{ctx, id}

	// Record call args
	mmGetPostByID.GetPostByIDMock.mutex.Lock()
	mmGetPostByID.GetPostByIDMock.callArgs = append(mmGetPostByID.GetPostByIDMock.callArgs, &mm_params)
	mmGetPostByID.GetPostByIDMock.mutex.Unlock()

	for _, e := range mmGetPostByID.GetPostByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPostByID.GetPostByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPostByID.GetPostByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPostByID.GetPostByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetPostByID.GetPostByIDMock.defaultExpectation.paramPtrs

		mm_got := PostServiceMockGetPostByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPostByID.t.Errorf("PostServiceMock.GetPostByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPostByID.GetPostByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetPostByID.t.Errorf("PostServiceMock.GetPostByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPostByID.GetPostByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPostByID.t.Errorf("PostServiceMock.GetPostByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPostByID.GetPostByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPostByID.GetPostByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPostByID.t.Fatal("No results are set for the PostServiceMock.GetPostByID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPostByID.funcGetPostByID != nil {
		return mmGetPostByID.funcGetPostByID(ctx, id)
	}
	mmGetPostByID.t.Fatalf("Unexpected call to PostServiceMock.GetPostByID. %v %v", ctx, id)
	return
}

// GetPostByIDAfterCounter returns a count of finished PostServiceMock.GetPostByID invocations
func (mmGetPostByID *PostServiceMock) GetPostByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostByID.afterGetPostByIDCounter)
}

// GetPostByIDBeforeCounter returns a count of PostServiceMock.GetPostByID invocations
func (mmGetPostByID *PostServiceMock) GetPostByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostByID.beforeGetPostByIDCounter)
}

// Calls returns a list of arguments used in each call to PostServiceMock.GetPostByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPostByID *mPostServiceMockGetPostByID) Calls() []*PostServiceMockGetPostByIDParams {
	mmGetPostByID.mutex.RLock()

	argCopy := make([]*PostServiceMockGetPostByIDParams, len(mmGetPostByID.callArgs))
	copy(argCopy, mmGetPostByID.callArgs)

	mmGetPostByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostByIDDone returns true if the count of the GetPostByID invocations corresponds
// the number of defined expectations
func (m *PostServiceMock) MinimockGetPostByIDDone() bool {
	if m.GetPostByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPostByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPostByIDMock.invocationsDone()
}

// MinimockGetPostByIDInspect logs each unmet expectation
func (m *PostServiceMock) MinimockGetPostByIDInspect() {
	for _, e := range m.GetPostByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostServiceMock.GetPostByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPostByIDCounter := mm_atomic.LoadUint64(&m.afterGetPostByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostByIDMock.defaultExpectation != nil && afterGetPostByIDCounter < 1 {
		if m.GetPostByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PostServiceMock.GetPostByID at\n%s", m.GetPostByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PostServiceMock.GetPostByID at\n%s with params: %#v", m.GetPostByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetPostByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPostByID != nil && afterGetPostByIDCounter < 1 {
		m.t.Errorf("Expected call to PostServiceMock.GetPostByID at\n%s", m.funcGetPostByIDOrigin)
	}

	if !m.GetPostByIDMock.invocationsDone() && afterGetPostByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to PostServiceMock.GetPostByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPostByIDMock.expectedInvocations), m.GetPostByIDMock.expectedInvocationsOrigin, afterGetPostByIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PostServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreatePostInspect()

			m.MinimockGetAllPostsInspect()

			m.MinimockGetPostByIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PostServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PostServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreatePostDone() &&
		m.MinimockGetAllPostsDone() &&
		m.MinimockGetPostByIDDone()
}
