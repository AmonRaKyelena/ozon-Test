// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package mocks

//go:generate minimock -i ozon-test-project/internal/pkg/storage.Storage -o storage_mock.go -n StorageMock -p mocks

import (
	"context"
	"ozon-test-project/internal/pkg/storage/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// StorageMock implements mm_storage.Storage
type StorageMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateComment          func(ctx context.Context, comment model.Comment) (i1 int64, err error)
	funcCreateCommentOrigin    string
	inspectFuncCreateComment   func(ctx context.Context, comment model.Comment)
	afterCreateCommentCounter  uint64
	beforeCreateCommentCounter uint64
	CreateCommentMock          mStorageMockCreateComment

	funcCreatePost          func(ctx context.Context, post model.Post) (i1 int64, err error)
	funcCreatePostOrigin    string
	inspectFuncCreatePost   func(ctx context.Context, post model.Post)
	afterCreatePostCounter  uint64
	beforeCreatePostCounter uint64
	CreatePostMock          mStorageMockCreatePost

	funcGetAllPosts          func(ctx context.Context, limit int32, offset int32) (pa1 []model.Post, err error)
	funcGetAllPostsOrigin    string
	inspectFuncGetAllPosts   func(ctx context.Context, limit int32, offset int32)
	afterGetAllPostsCounter  uint64
	beforeGetAllPostsCounter uint64
	GetAllPostsMock          mStorageMockGetAllPosts

	funcGetCommentsByParentID          func(ctx context.Context, parentID int64, limit int32, offset int32) (cpa1 []*model.CommentForPagination, err error)
	funcGetCommentsByParentIDOrigin    string
	inspectFuncGetCommentsByParentID   func(ctx context.Context, parentID int64, limit int32, offset int32)
	afterGetCommentsByParentIDCounter  uint64
	beforeGetCommentsByParentIDCounter uint64
	GetCommentsByParentIDMock          mStorageMockGetCommentsByParentID

	funcGetCommentsByPostIDs          func(ctx context.Context, postIDs []int64, limit int32, offset int32) (m1 map[int64][]model.CommentForPagination, err error)
	funcGetCommentsByPostIDsOrigin    string
	inspectFuncGetCommentsByPostIDs   func(ctx context.Context, postIDs []int64, limit int32, offset int32)
	afterGetCommentsByPostIDsCounter  uint64
	beforeGetCommentsByPostIDsCounter uint64
	GetCommentsByPostIDsMock          mStorageMockGetCommentsByPostIDs

	funcGetPostByID          func(ctx context.Context, id int64) (pp1 *model.Post, err error)
	funcGetPostByIDOrigin    string
	inspectFuncGetPostByID   func(ctx context.Context, id int64)
	afterGetPostByIDCounter  uint64
	beforeGetPostByIDCounter uint64
	GetPostByIDMock          mStorageMockGetPostByID
}

// NewStorageMock returns a mock for mm_storage.Storage
func NewStorageMock(t minimock.Tester) *StorageMock {
	m := &StorageMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateCommentMock = mStorageMockCreateComment{mock: m}
	m.CreateCommentMock.callArgs = []*StorageMockCreateCommentParams{}

	m.CreatePostMock = mStorageMockCreatePost{mock: m}
	m.CreatePostMock.callArgs = []*StorageMockCreatePostParams{}

	m.GetAllPostsMock = mStorageMockGetAllPosts{mock: m}
	m.GetAllPostsMock.callArgs = []*StorageMockGetAllPostsParams{}

	m.GetCommentsByParentIDMock = mStorageMockGetCommentsByParentID{mock: m}
	m.GetCommentsByParentIDMock.callArgs = []*StorageMockGetCommentsByParentIDParams{}

	m.GetCommentsByPostIDsMock = mStorageMockGetCommentsByPostIDs{mock: m}
	m.GetCommentsByPostIDsMock.callArgs = []*StorageMockGetCommentsByPostIDsParams{}

	m.GetPostByIDMock = mStorageMockGetPostByID{mock: m}
	m.GetPostByIDMock.callArgs = []*StorageMockGetPostByIDParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageMockCreateComment struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockCreateCommentExpectation
	expectations       []*StorageMockCreateCommentExpectation

	callArgs []*StorageMockCreateCommentParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockCreateCommentExpectation specifies expectation struct of the Storage.CreateComment
type StorageMockCreateCommentExpectation struct {
	mock               *StorageMock
	params             *StorageMockCreateCommentParams
	paramPtrs          *StorageMockCreateCommentParamPtrs
	expectationOrigins StorageMockCreateCommentExpectationOrigins
	results            *StorageMockCreateCommentResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockCreateCommentParams contains parameters of the Storage.CreateComment
type StorageMockCreateCommentParams struct {
	ctx     context.Context
	comment model.Comment
}

// StorageMockCreateCommentParamPtrs contains pointers to parameters of the Storage.CreateComment
type StorageMockCreateCommentParamPtrs struct {
	ctx     *context.Context
	comment *model.Comment
}

// StorageMockCreateCommentResults contains results of the Storage.CreateComment
type StorageMockCreateCommentResults struct {
	i1  int64
	err error
}

// StorageMockCreateCommentOrigins contains origins of expectations of the Storage.CreateComment
type StorageMockCreateCommentExpectationOrigins struct {
	origin        string
	originCtx     string
	originComment string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateComment *mStorageMockCreateComment) Optional() *mStorageMockCreateComment {
	mmCreateComment.optional = true
	return mmCreateComment
}

// Expect sets up expected params for Storage.CreateComment
func (mmCreateComment *mStorageMockCreateComment) Expect(ctx context.Context, comment model.Comment) *mStorageMockCreateComment {
	if mmCreateComment.mock.funcCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by Set")
	}

	if mmCreateComment.defaultExpectation == nil {
		mmCreateComment.defaultExpectation = &StorageMockCreateCommentExpectation{}
	}

	if mmCreateComment.defaultExpectation.paramPtrs != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by ExpectParams functions")
	}

	mmCreateComment.defaultExpectation.params = &StorageMockCreateCommentParams{ctx, comment}
	mmCreateComment.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateComment.expectations {
		if minimock.Equal(e.params, mmCreateComment.defaultExpectation.params) {
			mmCreateComment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateComment.defaultExpectation.params)
		}
	}

	return mmCreateComment
}

// ExpectCtxParam1 sets up expected param ctx for Storage.CreateComment
func (mmCreateComment *mStorageMockCreateComment) ExpectCtxParam1(ctx context.Context) *mStorageMockCreateComment {
	if mmCreateComment.mock.funcCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by Set")
	}

	if mmCreateComment.defaultExpectation == nil {
		mmCreateComment.defaultExpectation = &StorageMockCreateCommentExpectation{}
	}

	if mmCreateComment.defaultExpectation.params != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by Expect")
	}

	if mmCreateComment.defaultExpectation.paramPtrs == nil {
		mmCreateComment.defaultExpectation.paramPtrs = &StorageMockCreateCommentParamPtrs{}
	}
	mmCreateComment.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateComment.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateComment
}

// ExpectCommentParam2 sets up expected param comment for Storage.CreateComment
func (mmCreateComment *mStorageMockCreateComment) ExpectCommentParam2(comment model.Comment) *mStorageMockCreateComment {
	if mmCreateComment.mock.funcCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by Set")
	}

	if mmCreateComment.defaultExpectation == nil {
		mmCreateComment.defaultExpectation = &StorageMockCreateCommentExpectation{}
	}

	if mmCreateComment.defaultExpectation.params != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by Expect")
	}

	if mmCreateComment.defaultExpectation.paramPtrs == nil {
		mmCreateComment.defaultExpectation.paramPtrs = &StorageMockCreateCommentParamPtrs{}
	}
	mmCreateComment.defaultExpectation.paramPtrs.comment = &comment
	mmCreateComment.defaultExpectation.expectationOrigins.originComment = minimock.CallerInfo(1)

	return mmCreateComment
}

// Inspect accepts an inspector function that has same arguments as the Storage.CreateComment
func (mmCreateComment *mStorageMockCreateComment) Inspect(f func(ctx context.Context, comment model.Comment)) *mStorageMockCreateComment {
	if mmCreateComment.mock.inspectFuncCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("Inspect function is already set for StorageMock.CreateComment")
	}

	mmCreateComment.mock.inspectFuncCreateComment = f

	return mmCreateComment
}

// Return sets up results that will be returned by Storage.CreateComment
func (mmCreateComment *mStorageMockCreateComment) Return(i1 int64, err error) *StorageMock {
	if mmCreateComment.mock.funcCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by Set")
	}

	if mmCreateComment.defaultExpectation == nil {
		mmCreateComment.defaultExpectation = &StorageMockCreateCommentExpectation{mock: mmCreateComment.mock}
	}
	mmCreateComment.defaultExpectation.results = &StorageMockCreateCommentResults{i1, err}
	mmCreateComment.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateComment.mock
}

// Set uses given function f to mock the Storage.CreateComment method
func (mmCreateComment *mStorageMockCreateComment) Set(f func(ctx context.Context, comment model.Comment) (i1 int64, err error)) *StorageMock {
	if mmCreateComment.defaultExpectation != nil {
		mmCreateComment.mock.t.Fatalf("Default expectation is already set for the Storage.CreateComment method")
	}

	if len(mmCreateComment.expectations) > 0 {
		mmCreateComment.mock.t.Fatalf("Some expectations are already set for the Storage.CreateComment method")
	}

	mmCreateComment.mock.funcCreateComment = f
	mmCreateComment.mock.funcCreateCommentOrigin = minimock.CallerInfo(1)
	return mmCreateComment.mock
}

// When sets expectation for the Storage.CreateComment which will trigger the result defined by the following
// Then helper
func (mmCreateComment *mStorageMockCreateComment) When(ctx context.Context, comment model.Comment) *StorageMockCreateCommentExpectation {
	if mmCreateComment.mock.funcCreateComment != nil {
		mmCreateComment.mock.t.Fatalf("StorageMock.CreateComment mock is already set by Set")
	}

	expectation := &StorageMockCreateCommentExpectation{
		mock:               mmCreateComment.mock,
		params:             &StorageMockCreateCommentParams{ctx, comment},
		expectationOrigins: StorageMockCreateCommentExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateComment.expectations = append(mmCreateComment.expectations, expectation)
	return expectation
}

// Then sets up Storage.CreateComment return parameters for the expectation previously defined by the When method
func (e *StorageMockCreateCommentExpectation) Then(i1 int64, err error) *StorageMock {
	e.results = &StorageMockCreateCommentResults{i1, err}
	return e.mock
}

// Times sets number of times Storage.CreateComment should be invoked
func (mmCreateComment *mStorageMockCreateComment) Times(n uint64) *mStorageMockCreateComment {
	if n == 0 {
		mmCreateComment.mock.t.Fatalf("Times of StorageMock.CreateComment mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateComment.expectedInvocations, n)
	mmCreateComment.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateComment
}

func (mmCreateComment *mStorageMockCreateComment) invocationsDone() bool {
	if len(mmCreateComment.expectations) == 0 && mmCreateComment.defaultExpectation == nil && mmCreateComment.mock.funcCreateComment == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateComment.mock.afterCreateCommentCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateComment.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateComment implements mm_storage.Storage
func (mmCreateComment *StorageMock) CreateComment(ctx context.Context, comment model.Comment) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreateComment.beforeCreateCommentCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateComment.afterCreateCommentCounter, 1)

	mmCreateComment.t.Helper()

	if mmCreateComment.inspectFuncCreateComment != nil {
		mmCreateComment.inspectFuncCreateComment(ctx, comment)
	}

	mm_params := StorageMockCreateCommentParams{ctx, comment}

	// Record call args
	mmCreateComment.CreateCommentMock.mutex.Lock()
	mmCreateComment.CreateCommentMock.callArgs = append(mmCreateComment.CreateCommentMock.callArgs, &mm_params)
	mmCreateComment.CreateCommentMock.mutex.Unlock()

	for _, e := range mmCreateComment.CreateCommentMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreateComment.CreateCommentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateComment.CreateCommentMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateComment.CreateCommentMock.defaultExpectation.params
		mm_want_ptrs := mmCreateComment.CreateCommentMock.defaultExpectation.paramPtrs

		mm_got := StorageMockCreateCommentParams{ctx, comment}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateComment.t.Errorf("StorageMock.CreateComment got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateComment.CreateCommentMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.comment != nil && !minimock.Equal(*mm_want_ptrs.comment, mm_got.comment) {
				mmCreateComment.t.Errorf("StorageMock.CreateComment got unexpected parameter comment, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateComment.CreateCommentMock.defaultExpectation.expectationOrigins.originComment, *mm_want_ptrs.comment, mm_got.comment, minimock.Diff(*mm_want_ptrs.comment, mm_got.comment))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateComment.t.Errorf("StorageMock.CreateComment got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateComment.CreateCommentMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateComment.CreateCommentMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateComment.t.Fatal("No results are set for the StorageMock.CreateComment")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreateComment.funcCreateComment != nil {
		return mmCreateComment.funcCreateComment(ctx, comment)
	}
	mmCreateComment.t.Fatalf("Unexpected call to StorageMock.CreateComment. %v %v", ctx, comment)
	return
}

// CreateCommentAfterCounter returns a count of finished StorageMock.CreateComment invocations
func (mmCreateComment *StorageMock) CreateCommentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateComment.afterCreateCommentCounter)
}

// CreateCommentBeforeCounter returns a count of StorageMock.CreateComment invocations
func (mmCreateComment *StorageMock) CreateCommentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateComment.beforeCreateCommentCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.CreateComment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateComment *mStorageMockCreateComment) Calls() []*StorageMockCreateCommentParams {
	mmCreateComment.mutex.RLock()

	argCopy := make([]*StorageMockCreateCommentParams, len(mmCreateComment.callArgs))
	copy(argCopy, mmCreateComment.callArgs)

	mmCreateComment.mutex.RUnlock()

	return argCopy
}

// MinimockCreateCommentDone returns true if the count of the CreateComment invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCreateCommentDone() bool {
	if m.CreateCommentMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateCommentMock.invocationsDone()
}

// MinimockCreateCommentInspect logs each unmet expectation
func (m *StorageMock) MinimockCreateCommentInspect() {
	for _, e := range m.CreateCommentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.CreateComment at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCommentCounter := mm_atomic.LoadUint64(&m.afterCreateCommentCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateCommentMock.defaultExpectation != nil && afterCreateCommentCounter < 1 {
		if m.CreateCommentMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.CreateComment at\n%s", m.CreateCommentMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.CreateComment at\n%s with params: %#v", m.CreateCommentMock.defaultExpectation.expectationOrigins.origin, *m.CreateCommentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateComment != nil && afterCreateCommentCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.CreateComment at\n%s", m.funcCreateCommentOrigin)
	}

	if !m.CreateCommentMock.invocationsDone() && afterCreateCommentCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.CreateComment at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateCommentMock.expectedInvocations), m.CreateCommentMock.expectedInvocationsOrigin, afterCreateCommentCounter)
	}
}

type mStorageMockCreatePost struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockCreatePostExpectation
	expectations       []*StorageMockCreatePostExpectation

	callArgs []*StorageMockCreatePostParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockCreatePostExpectation specifies expectation struct of the Storage.CreatePost
type StorageMockCreatePostExpectation struct {
	mock               *StorageMock
	params             *StorageMockCreatePostParams
	paramPtrs          *StorageMockCreatePostParamPtrs
	expectationOrigins StorageMockCreatePostExpectationOrigins
	results            *StorageMockCreatePostResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockCreatePostParams contains parameters of the Storage.CreatePost
type StorageMockCreatePostParams struct {
	ctx  context.Context
	post model.Post
}

// StorageMockCreatePostParamPtrs contains pointers to parameters of the Storage.CreatePost
type StorageMockCreatePostParamPtrs struct {
	ctx  *context.Context
	post *model.Post
}

// StorageMockCreatePostResults contains results of the Storage.CreatePost
type StorageMockCreatePostResults struct {
	i1  int64
	err error
}

// StorageMockCreatePostOrigins contains origins of expectations of the Storage.CreatePost
type StorageMockCreatePostExpectationOrigins struct {
	origin     string
	originCtx  string
	originPost string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreatePost *mStorageMockCreatePost) Optional() *mStorageMockCreatePost {
	mmCreatePost.optional = true
	return mmCreatePost
}

// Expect sets up expected params for Storage.CreatePost
func (mmCreatePost *mStorageMockCreatePost) Expect(ctx context.Context, post model.Post) *mStorageMockCreatePost {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &StorageMockCreatePostExpectation{}
	}

	if mmCreatePost.defaultExpectation.paramPtrs != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by ExpectParams functions")
	}

	mmCreatePost.defaultExpectation.params = &StorageMockCreatePostParams{ctx, post}
	mmCreatePost.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreatePost.expectations {
		if minimock.Equal(e.params, mmCreatePost.defaultExpectation.params) {
			mmCreatePost.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePost.defaultExpectation.params)
		}
	}

	return mmCreatePost
}

// ExpectCtxParam1 sets up expected param ctx for Storage.CreatePost
func (mmCreatePost *mStorageMockCreatePost) ExpectCtxParam1(ctx context.Context) *mStorageMockCreatePost {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &StorageMockCreatePostExpectation{}
	}

	if mmCreatePost.defaultExpectation.params != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by Expect")
	}

	if mmCreatePost.defaultExpectation.paramPtrs == nil {
		mmCreatePost.defaultExpectation.paramPtrs = &StorageMockCreatePostParamPtrs{}
	}
	mmCreatePost.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreatePost.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreatePost
}

// ExpectPostParam2 sets up expected param post for Storage.CreatePost
func (mmCreatePost *mStorageMockCreatePost) ExpectPostParam2(post model.Post) *mStorageMockCreatePost {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &StorageMockCreatePostExpectation{}
	}

	if mmCreatePost.defaultExpectation.params != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by Expect")
	}

	if mmCreatePost.defaultExpectation.paramPtrs == nil {
		mmCreatePost.defaultExpectation.paramPtrs = &StorageMockCreatePostParamPtrs{}
	}
	mmCreatePost.defaultExpectation.paramPtrs.post = &post
	mmCreatePost.defaultExpectation.expectationOrigins.originPost = minimock.CallerInfo(1)

	return mmCreatePost
}

// Inspect accepts an inspector function that has same arguments as the Storage.CreatePost
func (mmCreatePost *mStorageMockCreatePost) Inspect(f func(ctx context.Context, post model.Post)) *mStorageMockCreatePost {
	if mmCreatePost.mock.inspectFuncCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("Inspect function is already set for StorageMock.CreatePost")
	}

	mmCreatePost.mock.inspectFuncCreatePost = f

	return mmCreatePost
}

// Return sets up results that will be returned by Storage.CreatePost
func (mmCreatePost *mStorageMockCreatePost) Return(i1 int64, err error) *StorageMock {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by Set")
	}

	if mmCreatePost.defaultExpectation == nil {
		mmCreatePost.defaultExpectation = &StorageMockCreatePostExpectation{mock: mmCreatePost.mock}
	}
	mmCreatePost.defaultExpectation.results = &StorageMockCreatePostResults{i1, err}
	mmCreatePost.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreatePost.mock
}

// Set uses given function f to mock the Storage.CreatePost method
func (mmCreatePost *mStorageMockCreatePost) Set(f func(ctx context.Context, post model.Post) (i1 int64, err error)) *StorageMock {
	if mmCreatePost.defaultExpectation != nil {
		mmCreatePost.mock.t.Fatalf("Default expectation is already set for the Storage.CreatePost method")
	}

	if len(mmCreatePost.expectations) > 0 {
		mmCreatePost.mock.t.Fatalf("Some expectations are already set for the Storage.CreatePost method")
	}

	mmCreatePost.mock.funcCreatePost = f
	mmCreatePost.mock.funcCreatePostOrigin = minimock.CallerInfo(1)
	return mmCreatePost.mock
}

// When sets expectation for the Storage.CreatePost which will trigger the result defined by the following
// Then helper
func (mmCreatePost *mStorageMockCreatePost) When(ctx context.Context, post model.Post) *StorageMockCreatePostExpectation {
	if mmCreatePost.mock.funcCreatePost != nil {
		mmCreatePost.mock.t.Fatalf("StorageMock.CreatePost mock is already set by Set")
	}

	expectation := &StorageMockCreatePostExpectation{
		mock:               mmCreatePost.mock,
		params:             &StorageMockCreatePostParams{ctx, post},
		expectationOrigins: StorageMockCreatePostExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreatePost.expectations = append(mmCreatePost.expectations, expectation)
	return expectation
}

// Then sets up Storage.CreatePost return parameters for the expectation previously defined by the When method
func (e *StorageMockCreatePostExpectation) Then(i1 int64, err error) *StorageMock {
	e.results = &StorageMockCreatePostResults{i1, err}
	return e.mock
}

// Times sets number of times Storage.CreatePost should be invoked
func (mmCreatePost *mStorageMockCreatePost) Times(n uint64) *mStorageMockCreatePost {
	if n == 0 {
		mmCreatePost.mock.t.Fatalf("Times of StorageMock.CreatePost mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreatePost.expectedInvocations, n)
	mmCreatePost.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreatePost
}

func (mmCreatePost *mStorageMockCreatePost) invocationsDone() bool {
	if len(mmCreatePost.expectations) == 0 && mmCreatePost.defaultExpectation == nil && mmCreatePost.mock.funcCreatePost == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreatePost.mock.afterCreatePostCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreatePost.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreatePost implements mm_storage.Storage
func (mmCreatePost *StorageMock) CreatePost(ctx context.Context, post model.Post) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmCreatePost.beforeCreatePostCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePost.afterCreatePostCounter, 1)

	mmCreatePost.t.Helper()

	if mmCreatePost.inspectFuncCreatePost != nil {
		mmCreatePost.inspectFuncCreatePost(ctx, post)
	}

	mm_params := StorageMockCreatePostParams{ctx, post}

	// Record call args
	mmCreatePost.CreatePostMock.mutex.Lock()
	mmCreatePost.CreatePostMock.callArgs = append(mmCreatePost.CreatePostMock.callArgs, &mm_params)
	mmCreatePost.CreatePostMock.mutex.Unlock()

	for _, e := range mmCreatePost.CreatePostMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmCreatePost.CreatePostMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePost.CreatePostMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePost.CreatePostMock.defaultExpectation.params
		mm_want_ptrs := mmCreatePost.CreatePostMock.defaultExpectation.paramPtrs

		mm_got := StorageMockCreatePostParams{ctx, post}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreatePost.t.Errorf("StorageMock.CreatePost got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePost.CreatePostMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.post != nil && !minimock.Equal(*mm_want_ptrs.post, mm_got.post) {
				mmCreatePost.t.Errorf("StorageMock.CreatePost got unexpected parameter post, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreatePost.CreatePostMock.defaultExpectation.expectationOrigins.originPost, *mm_want_ptrs.post, mm_got.post, minimock.Diff(*mm_want_ptrs.post, mm_got.post))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePost.t.Errorf("StorageMock.CreatePost got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreatePost.CreatePostMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePost.CreatePostMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePost.t.Fatal("No results are set for the StorageMock.CreatePost")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmCreatePost.funcCreatePost != nil {
		return mmCreatePost.funcCreatePost(ctx, post)
	}
	mmCreatePost.t.Fatalf("Unexpected call to StorageMock.CreatePost. %v %v", ctx, post)
	return
}

// CreatePostAfterCounter returns a count of finished StorageMock.CreatePost invocations
func (mmCreatePost *StorageMock) CreatePostAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePost.afterCreatePostCounter)
}

// CreatePostBeforeCounter returns a count of StorageMock.CreatePost invocations
func (mmCreatePost *StorageMock) CreatePostBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePost.beforeCreatePostCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.CreatePost.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePost *mStorageMockCreatePost) Calls() []*StorageMockCreatePostParams {
	mmCreatePost.mutex.RLock()

	argCopy := make([]*StorageMockCreatePostParams, len(mmCreatePost.callArgs))
	copy(argCopy, mmCreatePost.callArgs)

	mmCreatePost.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePostDone returns true if the count of the CreatePost invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockCreatePostDone() bool {
	if m.CreatePostMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreatePostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreatePostMock.invocationsDone()
}

// MinimockCreatePostInspect logs each unmet expectation
func (m *StorageMock) MinimockCreatePostInspect() {
	for _, e := range m.CreatePostMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.CreatePost at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreatePostCounter := mm_atomic.LoadUint64(&m.afterCreatePostCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePostMock.defaultExpectation != nil && afterCreatePostCounter < 1 {
		if m.CreatePostMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.CreatePost at\n%s", m.CreatePostMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.CreatePost at\n%s with params: %#v", m.CreatePostMock.defaultExpectation.expectationOrigins.origin, *m.CreatePostMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePost != nil && afterCreatePostCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.CreatePost at\n%s", m.funcCreatePostOrigin)
	}

	if !m.CreatePostMock.invocationsDone() && afterCreatePostCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.CreatePost at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreatePostMock.expectedInvocations), m.CreatePostMock.expectedInvocationsOrigin, afterCreatePostCounter)
	}
}

type mStorageMockGetAllPosts struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetAllPostsExpectation
	expectations       []*StorageMockGetAllPostsExpectation

	callArgs []*StorageMockGetAllPostsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetAllPostsExpectation specifies expectation struct of the Storage.GetAllPosts
type StorageMockGetAllPostsExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetAllPostsParams
	paramPtrs          *StorageMockGetAllPostsParamPtrs
	expectationOrigins StorageMockGetAllPostsExpectationOrigins
	results            *StorageMockGetAllPostsResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetAllPostsParams contains parameters of the Storage.GetAllPosts
type StorageMockGetAllPostsParams struct {
	ctx    context.Context
	limit  int32
	offset int32
}

// StorageMockGetAllPostsParamPtrs contains pointers to parameters of the Storage.GetAllPosts
type StorageMockGetAllPostsParamPtrs struct {
	ctx    *context.Context
	limit  *int32
	offset *int32
}

// StorageMockGetAllPostsResults contains results of the Storage.GetAllPosts
type StorageMockGetAllPostsResults struct {
	pa1 []model.Post
	err error
}

// StorageMockGetAllPostsOrigins contains origins of expectations of the Storage.GetAllPosts
type StorageMockGetAllPostsExpectationOrigins struct {
	origin       string
	originCtx    string
	originLimit  string
	originOffset string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllPosts *mStorageMockGetAllPosts) Optional() *mStorageMockGetAllPosts {
	mmGetAllPosts.optional = true
	return mmGetAllPosts
}

// Expect sets up expected params for Storage.GetAllPosts
func (mmGetAllPosts *mStorageMockGetAllPosts) Expect(ctx context.Context, limit int32, offset int32) *mStorageMockGetAllPosts {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("StorageMock.GetAllPosts mock is already set by Set")
	}

	if mmGetAllPosts.defaultExpectation == nil {
		mmGetAllPosts.defaultExpectation = &StorageMockGetAllPostsExpectation{}
	}

	if mmGetAllPosts.defaultExpectation.paramPtrs != nil {
		mmGetAllPosts.mock.t.Fatalf("StorageMock.GetAllPosts mock is already set by ExpectParams functions")
	}

	mmGetAllPosts.defaultExpectation.params = &StorageMockGetAllPostsParams{ctx, limit, offset}
	mmGetAllPosts.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAllPosts.expectations {
		if minimock.Equal(e.params, mmGetAllPosts.defaultExpectation.params) {
			mmGetAllPosts.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllPosts.defaultExpectation.params)
		}
	}

	return mmGetAllPosts
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetAllPosts
func (mmGetAllPosts *mStorageMockGetAllPosts) ExpectCtxParam1(ctx context.Context) *mStorageMockGetAllPosts {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("StorageMock.GetAllPosts mock is already set by Set")
	}

	if mmGetAllPosts.defaultExpectation == nil {
		mmGetAllPosts.defaultExpectation = &StorageMockGetAllPostsExpectation{}
	}

	if mmGetAllPosts.defaultExpectation.params != nil {
		mmGetAllPosts.mock.t.Fatalf("StorageMock.GetAllPosts mock is already set by Expect")
	}

	if mmGetAllPosts.defaultExpectation.paramPtrs == nil {
		mmGetAllPosts.defaultExpectation.paramPtrs = &StorageMockGetAllPostsParamPtrs{}
	}
	mmGetAllPosts.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAllPosts.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAllPosts
}

// ExpectLimitParam2 sets up expected param limit for Storage.GetAllPosts
func (mmGetAllPosts *mStorageMockGetAllPosts) ExpectLimitParam2(limit int32) *mStorageMockGetAllPosts {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("StorageMock.GetAllPosts mock is already set by Set")
	}

	if mmGetAllPosts.defaultExpectation == nil {
		mmGetAllPosts.defaultExpectation = &StorageMockGetAllPostsExpectation{}
	}

	if mmGetAllPosts.defaultExpectation.params != nil {
		mmGetAllPosts.mock.t.Fatalf("StorageMock.GetAllPosts mock is already set by Expect")
	}

	if mmGetAllPosts.defaultExpectation.paramPtrs == nil {
		mmGetAllPosts.defaultExpectation.paramPtrs = &StorageMockGetAllPostsParamPtrs{}
	}
	mmGetAllPosts.defaultExpectation.paramPtrs.limit = &limit
	mmGetAllPosts.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetAllPosts
}

// ExpectOffsetParam3 sets up expected param offset for Storage.GetAllPosts
func (mmGetAllPosts *mStorageMockGetAllPosts) ExpectOffsetParam3(offset int32) *mStorageMockGetAllPosts {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("StorageMock.GetAllPosts mock is already set by Set")
	}

	if mmGetAllPosts.defaultExpectation == nil {
		mmGetAllPosts.defaultExpectation = &StorageMockGetAllPostsExpectation{}
	}

	if mmGetAllPosts.defaultExpectation.params != nil {
		mmGetAllPosts.mock.t.Fatalf("StorageMock.GetAllPosts mock is already set by Expect")
	}

	if mmGetAllPosts.defaultExpectation.paramPtrs == nil {
		mmGetAllPosts.defaultExpectation.paramPtrs = &StorageMockGetAllPostsParamPtrs{}
	}
	mmGetAllPosts.defaultExpectation.paramPtrs.offset = &offset
	mmGetAllPosts.defaultExpectation.expectationOrigins.originOffset = minimock.CallerInfo(1)

	return mmGetAllPosts
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetAllPosts
func (mmGetAllPosts *mStorageMockGetAllPosts) Inspect(f func(ctx context.Context, limit int32, offset int32)) *mStorageMockGetAllPosts {
	if mmGetAllPosts.mock.inspectFuncGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("Inspect function is already set for StorageMock.GetAllPosts")
	}

	mmGetAllPosts.mock.inspectFuncGetAllPosts = f

	return mmGetAllPosts
}

// Return sets up results that will be returned by Storage.GetAllPosts
func (mmGetAllPosts *mStorageMockGetAllPosts) Return(pa1 []model.Post, err error) *StorageMock {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("StorageMock.GetAllPosts mock is already set by Set")
	}

	if mmGetAllPosts.defaultExpectation == nil {
		mmGetAllPosts.defaultExpectation = &StorageMockGetAllPostsExpectation{mock: mmGetAllPosts.mock}
	}
	mmGetAllPosts.defaultExpectation.results = &StorageMockGetAllPostsResults{pa1, err}
	mmGetAllPosts.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAllPosts.mock
}

// Set uses given function f to mock the Storage.GetAllPosts method
func (mmGetAllPosts *mStorageMockGetAllPosts) Set(f func(ctx context.Context, limit int32, offset int32) (pa1 []model.Post, err error)) *StorageMock {
	if mmGetAllPosts.defaultExpectation != nil {
		mmGetAllPosts.mock.t.Fatalf("Default expectation is already set for the Storage.GetAllPosts method")
	}

	if len(mmGetAllPosts.expectations) > 0 {
		mmGetAllPosts.mock.t.Fatalf("Some expectations are already set for the Storage.GetAllPosts method")
	}

	mmGetAllPosts.mock.funcGetAllPosts = f
	mmGetAllPosts.mock.funcGetAllPostsOrigin = minimock.CallerInfo(1)
	return mmGetAllPosts.mock
}

// When sets expectation for the Storage.GetAllPosts which will trigger the result defined by the following
// Then helper
func (mmGetAllPosts *mStorageMockGetAllPosts) When(ctx context.Context, limit int32, offset int32) *StorageMockGetAllPostsExpectation {
	if mmGetAllPosts.mock.funcGetAllPosts != nil {
		mmGetAllPosts.mock.t.Fatalf("StorageMock.GetAllPosts mock is already set by Set")
	}

	expectation := &StorageMockGetAllPostsExpectation{
		mock:               mmGetAllPosts.mock,
		params:             &StorageMockGetAllPostsParams{ctx, limit, offset},
		expectationOrigins: StorageMockGetAllPostsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAllPosts.expectations = append(mmGetAllPosts.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetAllPosts return parameters for the expectation previously defined by the When method
func (e *StorageMockGetAllPostsExpectation) Then(pa1 []model.Post, err error) *StorageMock {
	e.results = &StorageMockGetAllPostsResults{pa1, err}
	return e.mock
}

// Times sets number of times Storage.GetAllPosts should be invoked
func (mmGetAllPosts *mStorageMockGetAllPosts) Times(n uint64) *mStorageMockGetAllPosts {
	if n == 0 {
		mmGetAllPosts.mock.t.Fatalf("Times of StorageMock.GetAllPosts mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllPosts.expectedInvocations, n)
	mmGetAllPosts.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAllPosts
}

func (mmGetAllPosts *mStorageMockGetAllPosts) invocationsDone() bool {
	if len(mmGetAllPosts.expectations) == 0 && mmGetAllPosts.defaultExpectation == nil && mmGetAllPosts.mock.funcGetAllPosts == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllPosts.mock.afterGetAllPostsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllPosts.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllPosts implements mm_storage.Storage
func (mmGetAllPosts *StorageMock) GetAllPosts(ctx context.Context, limit int32, offset int32) (pa1 []model.Post, err error) {
	mm_atomic.AddUint64(&mmGetAllPosts.beforeGetAllPostsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllPosts.afterGetAllPostsCounter, 1)

	mmGetAllPosts.t.Helper()

	if mmGetAllPosts.inspectFuncGetAllPosts != nil {
		mmGetAllPosts.inspectFuncGetAllPosts(ctx, limit, offset)
	}

	mm_params := StorageMockGetAllPostsParams{ctx, limit, offset}

	// Record call args
	mmGetAllPosts.GetAllPostsMock.mutex.Lock()
	mmGetAllPosts.GetAllPostsMock.callArgs = append(mmGetAllPosts.GetAllPostsMock.callArgs, &mm_params)
	mmGetAllPosts.GetAllPostsMock.mutex.Unlock()

	for _, e := range mmGetAllPosts.GetAllPostsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmGetAllPosts.GetAllPostsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllPosts.GetAllPostsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllPosts.GetAllPostsMock.defaultExpectation.params
		mm_want_ptrs := mmGetAllPosts.GetAllPostsMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetAllPostsParams{ctx, limit, offset}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAllPosts.t.Errorf("StorageMock.GetAllPosts got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllPosts.GetAllPostsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetAllPosts.t.Errorf("StorageMock.GetAllPosts got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllPosts.GetAllPostsMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmGetAllPosts.t.Errorf("StorageMock.GetAllPosts got unexpected parameter offset, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAllPosts.GetAllPostsMock.defaultExpectation.expectationOrigins.originOffset, *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllPosts.t.Errorf("StorageMock.GetAllPosts got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAllPosts.GetAllPostsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllPosts.GetAllPostsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllPosts.t.Fatal("No results are set for the StorageMock.GetAllPosts")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmGetAllPosts.funcGetAllPosts != nil {
		return mmGetAllPosts.funcGetAllPosts(ctx, limit, offset)
	}
	mmGetAllPosts.t.Fatalf("Unexpected call to StorageMock.GetAllPosts. %v %v %v", ctx, limit, offset)
	return
}

// GetAllPostsAfterCounter returns a count of finished StorageMock.GetAllPosts invocations
func (mmGetAllPosts *StorageMock) GetAllPostsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllPosts.afterGetAllPostsCounter)
}

// GetAllPostsBeforeCounter returns a count of StorageMock.GetAllPosts invocations
func (mmGetAllPosts *StorageMock) GetAllPostsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllPosts.beforeGetAllPostsCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetAllPosts.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllPosts *mStorageMockGetAllPosts) Calls() []*StorageMockGetAllPostsParams {
	mmGetAllPosts.mutex.RLock()

	argCopy := make([]*StorageMockGetAllPostsParams, len(mmGetAllPosts.callArgs))
	copy(argCopy, mmGetAllPosts.callArgs)

	mmGetAllPosts.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllPostsDone returns true if the count of the GetAllPosts invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetAllPostsDone() bool {
	if m.GetAllPostsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllPostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllPostsMock.invocationsDone()
}

// MinimockGetAllPostsInspect logs each unmet expectation
func (m *StorageMock) MinimockGetAllPostsInspect() {
	for _, e := range m.GetAllPostsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetAllPosts at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllPostsCounter := mm_atomic.LoadUint64(&m.afterGetAllPostsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllPostsMock.defaultExpectation != nil && afterGetAllPostsCounter < 1 {
		if m.GetAllPostsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetAllPosts at\n%s", m.GetAllPostsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetAllPosts at\n%s with params: %#v", m.GetAllPostsMock.defaultExpectation.expectationOrigins.origin, *m.GetAllPostsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllPosts != nil && afterGetAllPostsCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetAllPosts at\n%s", m.funcGetAllPostsOrigin)
	}

	if !m.GetAllPostsMock.invocationsDone() && afterGetAllPostsCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetAllPosts at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllPostsMock.expectedInvocations), m.GetAllPostsMock.expectedInvocationsOrigin, afterGetAllPostsCounter)
	}
}

type mStorageMockGetCommentsByParentID struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetCommentsByParentIDExpectation
	expectations       []*StorageMockGetCommentsByParentIDExpectation

	callArgs []*StorageMockGetCommentsByParentIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetCommentsByParentIDExpectation specifies expectation struct of the Storage.GetCommentsByParentID
type StorageMockGetCommentsByParentIDExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetCommentsByParentIDParams
	paramPtrs          *StorageMockGetCommentsByParentIDParamPtrs
	expectationOrigins StorageMockGetCommentsByParentIDExpectationOrigins
	results            *StorageMockGetCommentsByParentIDResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetCommentsByParentIDParams contains parameters of the Storage.GetCommentsByParentID
type StorageMockGetCommentsByParentIDParams struct {
	ctx      context.Context
	parentID int64
	limit    int32
	offset   int32
}

// StorageMockGetCommentsByParentIDParamPtrs contains pointers to parameters of the Storage.GetCommentsByParentID
type StorageMockGetCommentsByParentIDParamPtrs struct {
	ctx      *context.Context
	parentID *int64
	limit    *int32
	offset   *int32
}

// StorageMockGetCommentsByParentIDResults contains results of the Storage.GetCommentsByParentID
type StorageMockGetCommentsByParentIDResults struct {
	cpa1 []*model.CommentForPagination
	err  error
}

// StorageMockGetCommentsByParentIDOrigins contains origins of expectations of the Storage.GetCommentsByParentID
type StorageMockGetCommentsByParentIDExpectationOrigins struct {
	origin         string
	originCtx      string
	originParentID string
	originLimit    string
	originOffset   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCommentsByParentID *mStorageMockGetCommentsByParentID) Optional() *mStorageMockGetCommentsByParentID {
	mmGetCommentsByParentID.optional = true
	return mmGetCommentsByParentID
}

// Expect sets up expected params for Storage.GetCommentsByParentID
func (mmGetCommentsByParentID *mStorageMockGetCommentsByParentID) Expect(ctx context.Context, parentID int64, limit int32, offset int32) *mStorageMockGetCommentsByParentID {
	if mmGetCommentsByParentID.mock.funcGetCommentsByParentID != nil {
		mmGetCommentsByParentID.mock.t.Fatalf("StorageMock.GetCommentsByParentID mock is already set by Set")
	}

	if mmGetCommentsByParentID.defaultExpectation == nil {
		mmGetCommentsByParentID.defaultExpectation = &StorageMockGetCommentsByParentIDExpectation{}
	}

	if mmGetCommentsByParentID.defaultExpectation.paramPtrs != nil {
		mmGetCommentsByParentID.mock.t.Fatalf("StorageMock.GetCommentsByParentID mock is already set by ExpectParams functions")
	}

	mmGetCommentsByParentID.defaultExpectation.params = &StorageMockGetCommentsByParentIDParams{ctx, parentID, limit, offset}
	mmGetCommentsByParentID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCommentsByParentID.expectations {
		if minimock.Equal(e.params, mmGetCommentsByParentID.defaultExpectation.params) {
			mmGetCommentsByParentID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCommentsByParentID.defaultExpectation.params)
		}
	}

	return mmGetCommentsByParentID
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetCommentsByParentID
func (mmGetCommentsByParentID *mStorageMockGetCommentsByParentID) ExpectCtxParam1(ctx context.Context) *mStorageMockGetCommentsByParentID {
	if mmGetCommentsByParentID.mock.funcGetCommentsByParentID != nil {
		mmGetCommentsByParentID.mock.t.Fatalf("StorageMock.GetCommentsByParentID mock is already set by Set")
	}

	if mmGetCommentsByParentID.defaultExpectation == nil {
		mmGetCommentsByParentID.defaultExpectation = &StorageMockGetCommentsByParentIDExpectation{}
	}

	if mmGetCommentsByParentID.defaultExpectation.params != nil {
		mmGetCommentsByParentID.mock.t.Fatalf("StorageMock.GetCommentsByParentID mock is already set by Expect")
	}

	if mmGetCommentsByParentID.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByParentID.defaultExpectation.paramPtrs = &StorageMockGetCommentsByParentIDParamPtrs{}
	}
	mmGetCommentsByParentID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCommentsByParentID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCommentsByParentID
}

// ExpectParentIDParam2 sets up expected param parentID for Storage.GetCommentsByParentID
func (mmGetCommentsByParentID *mStorageMockGetCommentsByParentID) ExpectParentIDParam2(parentID int64) *mStorageMockGetCommentsByParentID {
	if mmGetCommentsByParentID.mock.funcGetCommentsByParentID != nil {
		mmGetCommentsByParentID.mock.t.Fatalf("StorageMock.GetCommentsByParentID mock is already set by Set")
	}

	if mmGetCommentsByParentID.defaultExpectation == nil {
		mmGetCommentsByParentID.defaultExpectation = &StorageMockGetCommentsByParentIDExpectation{}
	}

	if mmGetCommentsByParentID.defaultExpectation.params != nil {
		mmGetCommentsByParentID.mock.t.Fatalf("StorageMock.GetCommentsByParentID mock is already set by Expect")
	}

	if mmGetCommentsByParentID.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByParentID.defaultExpectation.paramPtrs = &StorageMockGetCommentsByParentIDParamPtrs{}
	}
	mmGetCommentsByParentID.defaultExpectation.paramPtrs.parentID = &parentID
	mmGetCommentsByParentID.defaultExpectation.expectationOrigins.originParentID = minimock.CallerInfo(1)

	return mmGetCommentsByParentID
}

// ExpectLimitParam3 sets up expected param limit for Storage.GetCommentsByParentID
func (mmGetCommentsByParentID *mStorageMockGetCommentsByParentID) ExpectLimitParam3(limit int32) *mStorageMockGetCommentsByParentID {
	if mmGetCommentsByParentID.mock.funcGetCommentsByParentID != nil {
		mmGetCommentsByParentID.mock.t.Fatalf("StorageMock.GetCommentsByParentID mock is already set by Set")
	}

	if mmGetCommentsByParentID.defaultExpectation == nil {
		mmGetCommentsByParentID.defaultExpectation = &StorageMockGetCommentsByParentIDExpectation{}
	}

	if mmGetCommentsByParentID.defaultExpectation.params != nil {
		mmGetCommentsByParentID.mock.t.Fatalf("StorageMock.GetCommentsByParentID mock is already set by Expect")
	}

	if mmGetCommentsByParentID.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByParentID.defaultExpectation.paramPtrs = &StorageMockGetCommentsByParentIDParamPtrs{}
	}
	mmGetCommentsByParentID.defaultExpectation.paramPtrs.limit = &limit
	mmGetCommentsByParentID.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetCommentsByParentID
}

// ExpectOffsetParam4 sets up expected param offset for Storage.GetCommentsByParentID
func (mmGetCommentsByParentID *mStorageMockGetCommentsByParentID) ExpectOffsetParam4(offset int32) *mStorageMockGetCommentsByParentID {
	if mmGetCommentsByParentID.mock.funcGetCommentsByParentID != nil {
		mmGetCommentsByParentID.mock.t.Fatalf("StorageMock.GetCommentsByParentID mock is already set by Set")
	}

	if mmGetCommentsByParentID.defaultExpectation == nil {
		mmGetCommentsByParentID.defaultExpectation = &StorageMockGetCommentsByParentIDExpectation{}
	}

	if mmGetCommentsByParentID.defaultExpectation.params != nil {
		mmGetCommentsByParentID.mock.t.Fatalf("StorageMock.GetCommentsByParentID mock is already set by Expect")
	}

	if mmGetCommentsByParentID.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByParentID.defaultExpectation.paramPtrs = &StorageMockGetCommentsByParentIDParamPtrs{}
	}
	mmGetCommentsByParentID.defaultExpectation.paramPtrs.offset = &offset
	mmGetCommentsByParentID.defaultExpectation.expectationOrigins.originOffset = minimock.CallerInfo(1)

	return mmGetCommentsByParentID
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetCommentsByParentID
func (mmGetCommentsByParentID *mStorageMockGetCommentsByParentID) Inspect(f func(ctx context.Context, parentID int64, limit int32, offset int32)) *mStorageMockGetCommentsByParentID {
	if mmGetCommentsByParentID.mock.inspectFuncGetCommentsByParentID != nil {
		mmGetCommentsByParentID.mock.t.Fatalf("Inspect function is already set for StorageMock.GetCommentsByParentID")
	}

	mmGetCommentsByParentID.mock.inspectFuncGetCommentsByParentID = f

	return mmGetCommentsByParentID
}

// Return sets up results that will be returned by Storage.GetCommentsByParentID
func (mmGetCommentsByParentID *mStorageMockGetCommentsByParentID) Return(cpa1 []*model.CommentForPagination, err error) *StorageMock {
	if mmGetCommentsByParentID.mock.funcGetCommentsByParentID != nil {
		mmGetCommentsByParentID.mock.t.Fatalf("StorageMock.GetCommentsByParentID mock is already set by Set")
	}

	if mmGetCommentsByParentID.defaultExpectation == nil {
		mmGetCommentsByParentID.defaultExpectation = &StorageMockGetCommentsByParentIDExpectation{mock: mmGetCommentsByParentID.mock}
	}
	mmGetCommentsByParentID.defaultExpectation.results = &StorageMockGetCommentsByParentIDResults{cpa1, err}
	mmGetCommentsByParentID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCommentsByParentID.mock
}

// Set uses given function f to mock the Storage.GetCommentsByParentID method
func (mmGetCommentsByParentID *mStorageMockGetCommentsByParentID) Set(f func(ctx context.Context, parentID int64, limit int32, offset int32) (cpa1 []*model.CommentForPagination, err error)) *StorageMock {
	if mmGetCommentsByParentID.defaultExpectation != nil {
		mmGetCommentsByParentID.mock.t.Fatalf("Default expectation is already set for the Storage.GetCommentsByParentID method")
	}

	if len(mmGetCommentsByParentID.expectations) > 0 {
		mmGetCommentsByParentID.mock.t.Fatalf("Some expectations are already set for the Storage.GetCommentsByParentID method")
	}

	mmGetCommentsByParentID.mock.funcGetCommentsByParentID = f
	mmGetCommentsByParentID.mock.funcGetCommentsByParentIDOrigin = minimock.CallerInfo(1)
	return mmGetCommentsByParentID.mock
}

// When sets expectation for the Storage.GetCommentsByParentID which will trigger the result defined by the following
// Then helper
func (mmGetCommentsByParentID *mStorageMockGetCommentsByParentID) When(ctx context.Context, parentID int64, limit int32, offset int32) *StorageMockGetCommentsByParentIDExpectation {
	if mmGetCommentsByParentID.mock.funcGetCommentsByParentID != nil {
		mmGetCommentsByParentID.mock.t.Fatalf("StorageMock.GetCommentsByParentID mock is already set by Set")
	}

	expectation := &StorageMockGetCommentsByParentIDExpectation{
		mock:               mmGetCommentsByParentID.mock,
		params:             &StorageMockGetCommentsByParentIDParams{ctx, parentID, limit, offset},
		expectationOrigins: StorageMockGetCommentsByParentIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCommentsByParentID.expectations = append(mmGetCommentsByParentID.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetCommentsByParentID return parameters for the expectation previously defined by the When method
func (e *StorageMockGetCommentsByParentIDExpectation) Then(cpa1 []*model.CommentForPagination, err error) *StorageMock {
	e.results = &StorageMockGetCommentsByParentIDResults{cpa1, err}
	return e.mock
}

// Times sets number of times Storage.GetCommentsByParentID should be invoked
func (mmGetCommentsByParentID *mStorageMockGetCommentsByParentID) Times(n uint64) *mStorageMockGetCommentsByParentID {
	if n == 0 {
		mmGetCommentsByParentID.mock.t.Fatalf("Times of StorageMock.GetCommentsByParentID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCommentsByParentID.expectedInvocations, n)
	mmGetCommentsByParentID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCommentsByParentID
}

func (mmGetCommentsByParentID *mStorageMockGetCommentsByParentID) invocationsDone() bool {
	if len(mmGetCommentsByParentID.expectations) == 0 && mmGetCommentsByParentID.defaultExpectation == nil && mmGetCommentsByParentID.mock.funcGetCommentsByParentID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCommentsByParentID.mock.afterGetCommentsByParentIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCommentsByParentID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCommentsByParentID implements mm_storage.Storage
func (mmGetCommentsByParentID *StorageMock) GetCommentsByParentID(ctx context.Context, parentID int64, limit int32, offset int32) (cpa1 []*model.CommentForPagination, err error) {
	mm_atomic.AddUint64(&mmGetCommentsByParentID.beforeGetCommentsByParentIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCommentsByParentID.afterGetCommentsByParentIDCounter, 1)

	mmGetCommentsByParentID.t.Helper()

	if mmGetCommentsByParentID.inspectFuncGetCommentsByParentID != nil {
		mmGetCommentsByParentID.inspectFuncGetCommentsByParentID(ctx, parentID, limit, offset)
	}

	mm_params := StorageMockGetCommentsByParentIDParams{ctx, parentID, limit, offset}

	// Record call args
	mmGetCommentsByParentID.GetCommentsByParentIDMock.mutex.Lock()
	mmGetCommentsByParentID.GetCommentsByParentIDMock.callArgs = append(mmGetCommentsByParentID.GetCommentsByParentIDMock.callArgs, &mm_params)
	mmGetCommentsByParentID.GetCommentsByParentIDMock.mutex.Unlock()

	for _, e := range mmGetCommentsByParentID.GetCommentsByParentIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cpa1, e.results.err
		}
	}

	if mmGetCommentsByParentID.GetCommentsByParentIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCommentsByParentID.GetCommentsByParentIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCommentsByParentID.GetCommentsByParentIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetCommentsByParentID.GetCommentsByParentIDMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetCommentsByParentIDParams{ctx, parentID, limit, offset}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCommentsByParentID.t.Errorf("StorageMock.GetCommentsByParentID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentsByParentID.GetCommentsByParentIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.parentID != nil && !minimock.Equal(*mm_want_ptrs.parentID, mm_got.parentID) {
				mmGetCommentsByParentID.t.Errorf("StorageMock.GetCommentsByParentID got unexpected parameter parentID, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentsByParentID.GetCommentsByParentIDMock.defaultExpectation.expectationOrigins.originParentID, *mm_want_ptrs.parentID, mm_got.parentID, minimock.Diff(*mm_want_ptrs.parentID, mm_got.parentID))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetCommentsByParentID.t.Errorf("StorageMock.GetCommentsByParentID got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentsByParentID.GetCommentsByParentIDMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmGetCommentsByParentID.t.Errorf("StorageMock.GetCommentsByParentID got unexpected parameter offset, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentsByParentID.GetCommentsByParentIDMock.defaultExpectation.expectationOrigins.originOffset, *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCommentsByParentID.t.Errorf("StorageMock.GetCommentsByParentID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCommentsByParentID.GetCommentsByParentIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCommentsByParentID.GetCommentsByParentIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCommentsByParentID.t.Fatal("No results are set for the StorageMock.GetCommentsByParentID")
		}
		return (*mm_results).cpa1, (*mm_results).err
	}
	if mmGetCommentsByParentID.funcGetCommentsByParentID != nil {
		return mmGetCommentsByParentID.funcGetCommentsByParentID(ctx, parentID, limit, offset)
	}
	mmGetCommentsByParentID.t.Fatalf("Unexpected call to StorageMock.GetCommentsByParentID. %v %v %v %v", ctx, parentID, limit, offset)
	return
}

// GetCommentsByParentIDAfterCounter returns a count of finished StorageMock.GetCommentsByParentID invocations
func (mmGetCommentsByParentID *StorageMock) GetCommentsByParentIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentsByParentID.afterGetCommentsByParentIDCounter)
}

// GetCommentsByParentIDBeforeCounter returns a count of StorageMock.GetCommentsByParentID invocations
func (mmGetCommentsByParentID *StorageMock) GetCommentsByParentIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentsByParentID.beforeGetCommentsByParentIDCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetCommentsByParentID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCommentsByParentID *mStorageMockGetCommentsByParentID) Calls() []*StorageMockGetCommentsByParentIDParams {
	mmGetCommentsByParentID.mutex.RLock()

	argCopy := make([]*StorageMockGetCommentsByParentIDParams, len(mmGetCommentsByParentID.callArgs))
	copy(argCopy, mmGetCommentsByParentID.callArgs)

	mmGetCommentsByParentID.mutex.RUnlock()

	return argCopy
}

// MinimockGetCommentsByParentIDDone returns true if the count of the GetCommentsByParentID invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetCommentsByParentIDDone() bool {
	if m.GetCommentsByParentIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCommentsByParentIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCommentsByParentIDMock.invocationsDone()
}

// MinimockGetCommentsByParentIDInspect logs each unmet expectation
func (m *StorageMock) MinimockGetCommentsByParentIDInspect() {
	for _, e := range m.GetCommentsByParentIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetCommentsByParentID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCommentsByParentIDCounter := mm_atomic.LoadUint64(&m.afterGetCommentsByParentIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCommentsByParentIDMock.defaultExpectation != nil && afterGetCommentsByParentIDCounter < 1 {
		if m.GetCommentsByParentIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetCommentsByParentID at\n%s", m.GetCommentsByParentIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetCommentsByParentID at\n%s with params: %#v", m.GetCommentsByParentIDMock.defaultExpectation.expectationOrigins.origin, *m.GetCommentsByParentIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCommentsByParentID != nil && afterGetCommentsByParentIDCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetCommentsByParentID at\n%s", m.funcGetCommentsByParentIDOrigin)
	}

	if !m.GetCommentsByParentIDMock.invocationsDone() && afterGetCommentsByParentIDCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetCommentsByParentID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCommentsByParentIDMock.expectedInvocations), m.GetCommentsByParentIDMock.expectedInvocationsOrigin, afterGetCommentsByParentIDCounter)
	}
}

type mStorageMockGetCommentsByPostIDs struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetCommentsByPostIDsExpectation
	expectations       []*StorageMockGetCommentsByPostIDsExpectation

	callArgs []*StorageMockGetCommentsByPostIDsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetCommentsByPostIDsExpectation specifies expectation struct of the Storage.GetCommentsByPostIDs
type StorageMockGetCommentsByPostIDsExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetCommentsByPostIDsParams
	paramPtrs          *StorageMockGetCommentsByPostIDsParamPtrs
	expectationOrigins StorageMockGetCommentsByPostIDsExpectationOrigins
	results            *StorageMockGetCommentsByPostIDsResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetCommentsByPostIDsParams contains parameters of the Storage.GetCommentsByPostIDs
type StorageMockGetCommentsByPostIDsParams struct {
	ctx     context.Context
	postIDs []int64
	limit   int32
	offset  int32
}

// StorageMockGetCommentsByPostIDsParamPtrs contains pointers to parameters of the Storage.GetCommentsByPostIDs
type StorageMockGetCommentsByPostIDsParamPtrs struct {
	ctx     *context.Context
	postIDs *[]int64
	limit   *int32
	offset  *int32
}

// StorageMockGetCommentsByPostIDsResults contains results of the Storage.GetCommentsByPostIDs
type StorageMockGetCommentsByPostIDsResults struct {
	m1  map[int64][]model.CommentForPagination
	err error
}

// StorageMockGetCommentsByPostIDsOrigins contains origins of expectations of the Storage.GetCommentsByPostIDs
type StorageMockGetCommentsByPostIDsExpectationOrigins struct {
	origin        string
	originCtx     string
	originPostIDs string
	originLimit   string
	originOffset  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetCommentsByPostIDs *mStorageMockGetCommentsByPostIDs) Optional() *mStorageMockGetCommentsByPostIDs {
	mmGetCommentsByPostIDs.optional = true
	return mmGetCommentsByPostIDs
}

// Expect sets up expected params for Storage.GetCommentsByPostIDs
func (mmGetCommentsByPostIDs *mStorageMockGetCommentsByPostIDs) Expect(ctx context.Context, postIDs []int64, limit int32, offset int32) *mStorageMockGetCommentsByPostIDs {
	if mmGetCommentsByPostIDs.mock.funcGetCommentsByPostIDs != nil {
		mmGetCommentsByPostIDs.mock.t.Fatalf("StorageMock.GetCommentsByPostIDs mock is already set by Set")
	}

	if mmGetCommentsByPostIDs.defaultExpectation == nil {
		mmGetCommentsByPostIDs.defaultExpectation = &StorageMockGetCommentsByPostIDsExpectation{}
	}

	if mmGetCommentsByPostIDs.defaultExpectation.paramPtrs != nil {
		mmGetCommentsByPostIDs.mock.t.Fatalf("StorageMock.GetCommentsByPostIDs mock is already set by ExpectParams functions")
	}

	mmGetCommentsByPostIDs.defaultExpectation.params = &StorageMockGetCommentsByPostIDsParams{ctx, postIDs, limit, offset}
	mmGetCommentsByPostIDs.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetCommentsByPostIDs.expectations {
		if minimock.Equal(e.params, mmGetCommentsByPostIDs.defaultExpectation.params) {
			mmGetCommentsByPostIDs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetCommentsByPostIDs.defaultExpectation.params)
		}
	}

	return mmGetCommentsByPostIDs
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetCommentsByPostIDs
func (mmGetCommentsByPostIDs *mStorageMockGetCommentsByPostIDs) ExpectCtxParam1(ctx context.Context) *mStorageMockGetCommentsByPostIDs {
	if mmGetCommentsByPostIDs.mock.funcGetCommentsByPostIDs != nil {
		mmGetCommentsByPostIDs.mock.t.Fatalf("StorageMock.GetCommentsByPostIDs mock is already set by Set")
	}

	if mmGetCommentsByPostIDs.defaultExpectation == nil {
		mmGetCommentsByPostIDs.defaultExpectation = &StorageMockGetCommentsByPostIDsExpectation{}
	}

	if mmGetCommentsByPostIDs.defaultExpectation.params != nil {
		mmGetCommentsByPostIDs.mock.t.Fatalf("StorageMock.GetCommentsByPostIDs mock is already set by Expect")
	}

	if mmGetCommentsByPostIDs.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByPostIDs.defaultExpectation.paramPtrs = &StorageMockGetCommentsByPostIDsParamPtrs{}
	}
	mmGetCommentsByPostIDs.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetCommentsByPostIDs.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetCommentsByPostIDs
}

// ExpectPostIDsParam2 sets up expected param postIDs for Storage.GetCommentsByPostIDs
func (mmGetCommentsByPostIDs *mStorageMockGetCommentsByPostIDs) ExpectPostIDsParam2(postIDs []int64) *mStorageMockGetCommentsByPostIDs {
	if mmGetCommentsByPostIDs.mock.funcGetCommentsByPostIDs != nil {
		mmGetCommentsByPostIDs.mock.t.Fatalf("StorageMock.GetCommentsByPostIDs mock is already set by Set")
	}

	if mmGetCommentsByPostIDs.defaultExpectation == nil {
		mmGetCommentsByPostIDs.defaultExpectation = &StorageMockGetCommentsByPostIDsExpectation{}
	}

	if mmGetCommentsByPostIDs.defaultExpectation.params != nil {
		mmGetCommentsByPostIDs.mock.t.Fatalf("StorageMock.GetCommentsByPostIDs mock is already set by Expect")
	}

	if mmGetCommentsByPostIDs.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByPostIDs.defaultExpectation.paramPtrs = &StorageMockGetCommentsByPostIDsParamPtrs{}
	}
	mmGetCommentsByPostIDs.defaultExpectation.paramPtrs.postIDs = &postIDs
	mmGetCommentsByPostIDs.defaultExpectation.expectationOrigins.originPostIDs = minimock.CallerInfo(1)

	return mmGetCommentsByPostIDs
}

// ExpectLimitParam3 sets up expected param limit for Storage.GetCommentsByPostIDs
func (mmGetCommentsByPostIDs *mStorageMockGetCommentsByPostIDs) ExpectLimitParam3(limit int32) *mStorageMockGetCommentsByPostIDs {
	if mmGetCommentsByPostIDs.mock.funcGetCommentsByPostIDs != nil {
		mmGetCommentsByPostIDs.mock.t.Fatalf("StorageMock.GetCommentsByPostIDs mock is already set by Set")
	}

	if mmGetCommentsByPostIDs.defaultExpectation == nil {
		mmGetCommentsByPostIDs.defaultExpectation = &StorageMockGetCommentsByPostIDsExpectation{}
	}

	if mmGetCommentsByPostIDs.defaultExpectation.params != nil {
		mmGetCommentsByPostIDs.mock.t.Fatalf("StorageMock.GetCommentsByPostIDs mock is already set by Expect")
	}

	if mmGetCommentsByPostIDs.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByPostIDs.defaultExpectation.paramPtrs = &StorageMockGetCommentsByPostIDsParamPtrs{}
	}
	mmGetCommentsByPostIDs.defaultExpectation.paramPtrs.limit = &limit
	mmGetCommentsByPostIDs.defaultExpectation.expectationOrigins.originLimit = minimock.CallerInfo(1)

	return mmGetCommentsByPostIDs
}

// ExpectOffsetParam4 sets up expected param offset for Storage.GetCommentsByPostIDs
func (mmGetCommentsByPostIDs *mStorageMockGetCommentsByPostIDs) ExpectOffsetParam4(offset int32) *mStorageMockGetCommentsByPostIDs {
	if mmGetCommentsByPostIDs.mock.funcGetCommentsByPostIDs != nil {
		mmGetCommentsByPostIDs.mock.t.Fatalf("StorageMock.GetCommentsByPostIDs mock is already set by Set")
	}

	if mmGetCommentsByPostIDs.defaultExpectation == nil {
		mmGetCommentsByPostIDs.defaultExpectation = &StorageMockGetCommentsByPostIDsExpectation{}
	}

	if mmGetCommentsByPostIDs.defaultExpectation.params != nil {
		mmGetCommentsByPostIDs.mock.t.Fatalf("StorageMock.GetCommentsByPostIDs mock is already set by Expect")
	}

	if mmGetCommentsByPostIDs.defaultExpectation.paramPtrs == nil {
		mmGetCommentsByPostIDs.defaultExpectation.paramPtrs = &StorageMockGetCommentsByPostIDsParamPtrs{}
	}
	mmGetCommentsByPostIDs.defaultExpectation.paramPtrs.offset = &offset
	mmGetCommentsByPostIDs.defaultExpectation.expectationOrigins.originOffset = minimock.CallerInfo(1)

	return mmGetCommentsByPostIDs
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetCommentsByPostIDs
func (mmGetCommentsByPostIDs *mStorageMockGetCommentsByPostIDs) Inspect(f func(ctx context.Context, postIDs []int64, limit int32, offset int32)) *mStorageMockGetCommentsByPostIDs {
	if mmGetCommentsByPostIDs.mock.inspectFuncGetCommentsByPostIDs != nil {
		mmGetCommentsByPostIDs.mock.t.Fatalf("Inspect function is already set for StorageMock.GetCommentsByPostIDs")
	}

	mmGetCommentsByPostIDs.mock.inspectFuncGetCommentsByPostIDs = f

	return mmGetCommentsByPostIDs
}

// Return sets up results that will be returned by Storage.GetCommentsByPostIDs
func (mmGetCommentsByPostIDs *mStorageMockGetCommentsByPostIDs) Return(m1 map[int64][]model.CommentForPagination, err error) *StorageMock {
	if mmGetCommentsByPostIDs.mock.funcGetCommentsByPostIDs != nil {
		mmGetCommentsByPostIDs.mock.t.Fatalf("StorageMock.GetCommentsByPostIDs mock is already set by Set")
	}

	if mmGetCommentsByPostIDs.defaultExpectation == nil {
		mmGetCommentsByPostIDs.defaultExpectation = &StorageMockGetCommentsByPostIDsExpectation{mock: mmGetCommentsByPostIDs.mock}
	}
	mmGetCommentsByPostIDs.defaultExpectation.results = &StorageMockGetCommentsByPostIDsResults{m1, err}
	mmGetCommentsByPostIDs.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetCommentsByPostIDs.mock
}

// Set uses given function f to mock the Storage.GetCommentsByPostIDs method
func (mmGetCommentsByPostIDs *mStorageMockGetCommentsByPostIDs) Set(f func(ctx context.Context, postIDs []int64, limit int32, offset int32) (m1 map[int64][]model.CommentForPagination, err error)) *StorageMock {
	if mmGetCommentsByPostIDs.defaultExpectation != nil {
		mmGetCommentsByPostIDs.mock.t.Fatalf("Default expectation is already set for the Storage.GetCommentsByPostIDs method")
	}

	if len(mmGetCommentsByPostIDs.expectations) > 0 {
		mmGetCommentsByPostIDs.mock.t.Fatalf("Some expectations are already set for the Storage.GetCommentsByPostIDs method")
	}

	mmGetCommentsByPostIDs.mock.funcGetCommentsByPostIDs = f
	mmGetCommentsByPostIDs.mock.funcGetCommentsByPostIDsOrigin = minimock.CallerInfo(1)
	return mmGetCommentsByPostIDs.mock
}

// When sets expectation for the Storage.GetCommentsByPostIDs which will trigger the result defined by the following
// Then helper
func (mmGetCommentsByPostIDs *mStorageMockGetCommentsByPostIDs) When(ctx context.Context, postIDs []int64, limit int32, offset int32) *StorageMockGetCommentsByPostIDsExpectation {
	if mmGetCommentsByPostIDs.mock.funcGetCommentsByPostIDs != nil {
		mmGetCommentsByPostIDs.mock.t.Fatalf("StorageMock.GetCommentsByPostIDs mock is already set by Set")
	}

	expectation := &StorageMockGetCommentsByPostIDsExpectation{
		mock:               mmGetCommentsByPostIDs.mock,
		params:             &StorageMockGetCommentsByPostIDsParams{ctx, postIDs, limit, offset},
		expectationOrigins: StorageMockGetCommentsByPostIDsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetCommentsByPostIDs.expectations = append(mmGetCommentsByPostIDs.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetCommentsByPostIDs return parameters for the expectation previously defined by the When method
func (e *StorageMockGetCommentsByPostIDsExpectation) Then(m1 map[int64][]model.CommentForPagination, err error) *StorageMock {
	e.results = &StorageMockGetCommentsByPostIDsResults{m1, err}
	return e.mock
}

// Times sets number of times Storage.GetCommentsByPostIDs should be invoked
func (mmGetCommentsByPostIDs *mStorageMockGetCommentsByPostIDs) Times(n uint64) *mStorageMockGetCommentsByPostIDs {
	if n == 0 {
		mmGetCommentsByPostIDs.mock.t.Fatalf("Times of StorageMock.GetCommentsByPostIDs mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetCommentsByPostIDs.expectedInvocations, n)
	mmGetCommentsByPostIDs.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetCommentsByPostIDs
}

func (mmGetCommentsByPostIDs *mStorageMockGetCommentsByPostIDs) invocationsDone() bool {
	if len(mmGetCommentsByPostIDs.expectations) == 0 && mmGetCommentsByPostIDs.defaultExpectation == nil && mmGetCommentsByPostIDs.mock.funcGetCommentsByPostIDs == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetCommentsByPostIDs.mock.afterGetCommentsByPostIDsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetCommentsByPostIDs.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetCommentsByPostIDs implements mm_storage.Storage
func (mmGetCommentsByPostIDs *StorageMock) GetCommentsByPostIDs(ctx context.Context, postIDs []int64, limit int32, offset int32) (m1 map[int64][]model.CommentForPagination, err error) {
	mm_atomic.AddUint64(&mmGetCommentsByPostIDs.beforeGetCommentsByPostIDsCounter, 1)
	defer mm_atomic.AddUint64(&mmGetCommentsByPostIDs.afterGetCommentsByPostIDsCounter, 1)

	mmGetCommentsByPostIDs.t.Helper()

	if mmGetCommentsByPostIDs.inspectFuncGetCommentsByPostIDs != nil {
		mmGetCommentsByPostIDs.inspectFuncGetCommentsByPostIDs(ctx, postIDs, limit, offset)
	}

	mm_params := StorageMockGetCommentsByPostIDsParams{ctx, postIDs, limit, offset}

	// Record call args
	mmGetCommentsByPostIDs.GetCommentsByPostIDsMock.mutex.Lock()
	mmGetCommentsByPostIDs.GetCommentsByPostIDsMock.callArgs = append(mmGetCommentsByPostIDs.GetCommentsByPostIDsMock.callArgs, &mm_params)
	mmGetCommentsByPostIDs.GetCommentsByPostIDsMock.mutex.Unlock()

	for _, e := range mmGetCommentsByPostIDs.GetCommentsByPostIDsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.m1, e.results.err
		}
	}

	if mmGetCommentsByPostIDs.GetCommentsByPostIDsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetCommentsByPostIDs.GetCommentsByPostIDsMock.defaultExpectation.Counter, 1)
		mm_want := mmGetCommentsByPostIDs.GetCommentsByPostIDsMock.defaultExpectation.params
		mm_want_ptrs := mmGetCommentsByPostIDs.GetCommentsByPostIDsMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetCommentsByPostIDsParams{ctx, postIDs, limit, offset}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetCommentsByPostIDs.t.Errorf("StorageMock.GetCommentsByPostIDs got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentsByPostIDs.GetCommentsByPostIDsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.postIDs != nil && !minimock.Equal(*mm_want_ptrs.postIDs, mm_got.postIDs) {
				mmGetCommentsByPostIDs.t.Errorf("StorageMock.GetCommentsByPostIDs got unexpected parameter postIDs, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentsByPostIDs.GetCommentsByPostIDsMock.defaultExpectation.expectationOrigins.originPostIDs, *mm_want_ptrs.postIDs, mm_got.postIDs, minimock.Diff(*mm_want_ptrs.postIDs, mm_got.postIDs))
			}

			if mm_want_ptrs.limit != nil && !minimock.Equal(*mm_want_ptrs.limit, mm_got.limit) {
				mmGetCommentsByPostIDs.t.Errorf("StorageMock.GetCommentsByPostIDs got unexpected parameter limit, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentsByPostIDs.GetCommentsByPostIDsMock.defaultExpectation.expectationOrigins.originLimit, *mm_want_ptrs.limit, mm_got.limit, minimock.Diff(*mm_want_ptrs.limit, mm_got.limit))
			}

			if mm_want_ptrs.offset != nil && !minimock.Equal(*mm_want_ptrs.offset, mm_got.offset) {
				mmGetCommentsByPostIDs.t.Errorf("StorageMock.GetCommentsByPostIDs got unexpected parameter offset, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetCommentsByPostIDs.GetCommentsByPostIDsMock.defaultExpectation.expectationOrigins.originOffset, *mm_want_ptrs.offset, mm_got.offset, minimock.Diff(*mm_want_ptrs.offset, mm_got.offset))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetCommentsByPostIDs.t.Errorf("StorageMock.GetCommentsByPostIDs got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetCommentsByPostIDs.GetCommentsByPostIDsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetCommentsByPostIDs.GetCommentsByPostIDsMock.defaultExpectation.results
		if mm_results == nil {
			mmGetCommentsByPostIDs.t.Fatal("No results are set for the StorageMock.GetCommentsByPostIDs")
		}
		return (*mm_results).m1, (*mm_results).err
	}
	if mmGetCommentsByPostIDs.funcGetCommentsByPostIDs != nil {
		return mmGetCommentsByPostIDs.funcGetCommentsByPostIDs(ctx, postIDs, limit, offset)
	}
	mmGetCommentsByPostIDs.t.Fatalf("Unexpected call to StorageMock.GetCommentsByPostIDs. %v %v %v %v", ctx, postIDs, limit, offset)
	return
}

// GetCommentsByPostIDsAfterCounter returns a count of finished StorageMock.GetCommentsByPostIDs invocations
func (mmGetCommentsByPostIDs *StorageMock) GetCommentsByPostIDsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentsByPostIDs.afterGetCommentsByPostIDsCounter)
}

// GetCommentsByPostIDsBeforeCounter returns a count of StorageMock.GetCommentsByPostIDs invocations
func (mmGetCommentsByPostIDs *StorageMock) GetCommentsByPostIDsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetCommentsByPostIDs.beforeGetCommentsByPostIDsCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetCommentsByPostIDs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetCommentsByPostIDs *mStorageMockGetCommentsByPostIDs) Calls() []*StorageMockGetCommentsByPostIDsParams {
	mmGetCommentsByPostIDs.mutex.RLock()

	argCopy := make([]*StorageMockGetCommentsByPostIDsParams, len(mmGetCommentsByPostIDs.callArgs))
	copy(argCopy, mmGetCommentsByPostIDs.callArgs)

	mmGetCommentsByPostIDs.mutex.RUnlock()

	return argCopy
}

// MinimockGetCommentsByPostIDsDone returns true if the count of the GetCommentsByPostIDs invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetCommentsByPostIDsDone() bool {
	if m.GetCommentsByPostIDsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetCommentsByPostIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetCommentsByPostIDsMock.invocationsDone()
}

// MinimockGetCommentsByPostIDsInspect logs each unmet expectation
func (m *StorageMock) MinimockGetCommentsByPostIDsInspect() {
	for _, e := range m.GetCommentsByPostIDsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetCommentsByPostIDs at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetCommentsByPostIDsCounter := mm_atomic.LoadUint64(&m.afterGetCommentsByPostIDsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetCommentsByPostIDsMock.defaultExpectation != nil && afterGetCommentsByPostIDsCounter < 1 {
		if m.GetCommentsByPostIDsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetCommentsByPostIDs at\n%s", m.GetCommentsByPostIDsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetCommentsByPostIDs at\n%s with params: %#v", m.GetCommentsByPostIDsMock.defaultExpectation.expectationOrigins.origin, *m.GetCommentsByPostIDsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetCommentsByPostIDs != nil && afterGetCommentsByPostIDsCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetCommentsByPostIDs at\n%s", m.funcGetCommentsByPostIDsOrigin)
	}

	if !m.GetCommentsByPostIDsMock.invocationsDone() && afterGetCommentsByPostIDsCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetCommentsByPostIDs at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetCommentsByPostIDsMock.expectedInvocations), m.GetCommentsByPostIDsMock.expectedInvocationsOrigin, afterGetCommentsByPostIDsCounter)
	}
}

type mStorageMockGetPostByID struct {
	optional           bool
	mock               *StorageMock
	defaultExpectation *StorageMockGetPostByIDExpectation
	expectations       []*StorageMockGetPostByIDExpectation

	callArgs []*StorageMockGetPostByIDParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageMockGetPostByIDExpectation specifies expectation struct of the Storage.GetPostByID
type StorageMockGetPostByIDExpectation struct {
	mock               *StorageMock
	params             *StorageMockGetPostByIDParams
	paramPtrs          *StorageMockGetPostByIDParamPtrs
	expectationOrigins StorageMockGetPostByIDExpectationOrigins
	results            *StorageMockGetPostByIDResults
	returnOrigin       string
	Counter            uint64
}

// StorageMockGetPostByIDParams contains parameters of the Storage.GetPostByID
type StorageMockGetPostByIDParams struct {
	ctx context.Context
	id  int64
}

// StorageMockGetPostByIDParamPtrs contains pointers to parameters of the Storage.GetPostByID
type StorageMockGetPostByIDParamPtrs struct {
	ctx *context.Context
	id  *int64
}

// StorageMockGetPostByIDResults contains results of the Storage.GetPostByID
type StorageMockGetPostByIDResults struct {
	pp1 *model.Post
	err error
}

// StorageMockGetPostByIDOrigins contains origins of expectations of the Storage.GetPostByID
type StorageMockGetPostByIDExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetPostByID *mStorageMockGetPostByID) Optional() *mStorageMockGetPostByID {
	mmGetPostByID.optional = true
	return mmGetPostByID
}

// Expect sets up expected params for Storage.GetPostByID
func (mmGetPostByID *mStorageMockGetPostByID) Expect(ctx context.Context, id int64) *mStorageMockGetPostByID {
	if mmGetPostByID.mock.funcGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by Set")
	}

	if mmGetPostByID.defaultExpectation == nil {
		mmGetPostByID.defaultExpectation = &StorageMockGetPostByIDExpectation{}
	}

	if mmGetPostByID.defaultExpectation.paramPtrs != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by ExpectParams functions")
	}

	mmGetPostByID.defaultExpectation.params = &StorageMockGetPostByIDParams{ctx, id}
	mmGetPostByID.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetPostByID.expectations {
		if minimock.Equal(e.params, mmGetPostByID.defaultExpectation.params) {
			mmGetPostByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPostByID.defaultExpectation.params)
		}
	}

	return mmGetPostByID
}

// ExpectCtxParam1 sets up expected param ctx for Storage.GetPostByID
func (mmGetPostByID *mStorageMockGetPostByID) ExpectCtxParam1(ctx context.Context) *mStorageMockGetPostByID {
	if mmGetPostByID.mock.funcGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by Set")
	}

	if mmGetPostByID.defaultExpectation == nil {
		mmGetPostByID.defaultExpectation = &StorageMockGetPostByIDExpectation{}
	}

	if mmGetPostByID.defaultExpectation.params != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by Expect")
	}

	if mmGetPostByID.defaultExpectation.paramPtrs == nil {
		mmGetPostByID.defaultExpectation.paramPtrs = &StorageMockGetPostByIDParamPtrs{}
	}
	mmGetPostByID.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetPostByID.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetPostByID
}

// ExpectIdParam2 sets up expected param id for Storage.GetPostByID
func (mmGetPostByID *mStorageMockGetPostByID) ExpectIdParam2(id int64) *mStorageMockGetPostByID {
	if mmGetPostByID.mock.funcGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by Set")
	}

	if mmGetPostByID.defaultExpectation == nil {
		mmGetPostByID.defaultExpectation = &StorageMockGetPostByIDExpectation{}
	}

	if mmGetPostByID.defaultExpectation.params != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by Expect")
	}

	if mmGetPostByID.defaultExpectation.paramPtrs == nil {
		mmGetPostByID.defaultExpectation.paramPtrs = &StorageMockGetPostByIDParamPtrs{}
	}
	mmGetPostByID.defaultExpectation.paramPtrs.id = &id
	mmGetPostByID.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmGetPostByID
}

// Inspect accepts an inspector function that has same arguments as the Storage.GetPostByID
func (mmGetPostByID *mStorageMockGetPostByID) Inspect(f func(ctx context.Context, id int64)) *mStorageMockGetPostByID {
	if mmGetPostByID.mock.inspectFuncGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("Inspect function is already set for StorageMock.GetPostByID")
	}

	mmGetPostByID.mock.inspectFuncGetPostByID = f

	return mmGetPostByID
}

// Return sets up results that will be returned by Storage.GetPostByID
func (mmGetPostByID *mStorageMockGetPostByID) Return(pp1 *model.Post, err error) *StorageMock {
	if mmGetPostByID.mock.funcGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by Set")
	}

	if mmGetPostByID.defaultExpectation == nil {
		mmGetPostByID.defaultExpectation = &StorageMockGetPostByIDExpectation{mock: mmGetPostByID.mock}
	}
	mmGetPostByID.defaultExpectation.results = &StorageMockGetPostByIDResults{pp1, err}
	mmGetPostByID.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetPostByID.mock
}

// Set uses given function f to mock the Storage.GetPostByID method
func (mmGetPostByID *mStorageMockGetPostByID) Set(f func(ctx context.Context, id int64) (pp1 *model.Post, err error)) *StorageMock {
	if mmGetPostByID.defaultExpectation != nil {
		mmGetPostByID.mock.t.Fatalf("Default expectation is already set for the Storage.GetPostByID method")
	}

	if len(mmGetPostByID.expectations) > 0 {
		mmGetPostByID.mock.t.Fatalf("Some expectations are already set for the Storage.GetPostByID method")
	}

	mmGetPostByID.mock.funcGetPostByID = f
	mmGetPostByID.mock.funcGetPostByIDOrigin = minimock.CallerInfo(1)
	return mmGetPostByID.mock
}

// When sets expectation for the Storage.GetPostByID which will trigger the result defined by the following
// Then helper
func (mmGetPostByID *mStorageMockGetPostByID) When(ctx context.Context, id int64) *StorageMockGetPostByIDExpectation {
	if mmGetPostByID.mock.funcGetPostByID != nil {
		mmGetPostByID.mock.t.Fatalf("StorageMock.GetPostByID mock is already set by Set")
	}

	expectation := &StorageMockGetPostByIDExpectation{
		mock:               mmGetPostByID.mock,
		params:             &StorageMockGetPostByIDParams{ctx, id},
		expectationOrigins: StorageMockGetPostByIDExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetPostByID.expectations = append(mmGetPostByID.expectations, expectation)
	return expectation
}

// Then sets up Storage.GetPostByID return parameters for the expectation previously defined by the When method
func (e *StorageMockGetPostByIDExpectation) Then(pp1 *model.Post, err error) *StorageMock {
	e.results = &StorageMockGetPostByIDResults{pp1, err}
	return e.mock
}

// Times sets number of times Storage.GetPostByID should be invoked
func (mmGetPostByID *mStorageMockGetPostByID) Times(n uint64) *mStorageMockGetPostByID {
	if n == 0 {
		mmGetPostByID.mock.t.Fatalf("Times of StorageMock.GetPostByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetPostByID.expectedInvocations, n)
	mmGetPostByID.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetPostByID
}

func (mmGetPostByID *mStorageMockGetPostByID) invocationsDone() bool {
	if len(mmGetPostByID.expectations) == 0 && mmGetPostByID.defaultExpectation == nil && mmGetPostByID.mock.funcGetPostByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetPostByID.mock.afterGetPostByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetPostByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetPostByID implements mm_storage.Storage
func (mmGetPostByID *StorageMock) GetPostByID(ctx context.Context, id int64) (pp1 *model.Post, err error) {
	mm_atomic.AddUint64(&mmGetPostByID.beforeGetPostByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPostByID.afterGetPostByIDCounter, 1)

	mmGetPostByID.t.Helper()

	if mmGetPostByID.inspectFuncGetPostByID != nil {
		mmGetPostByID.inspectFuncGetPostByID(ctx, id)
	}

	mm_params := StorageMockGetPostByIDParams{ctx, id}

	// Record call args
	mmGetPostByID.GetPostByIDMock.mutex.Lock()
	mmGetPostByID.GetPostByIDMock.callArgs = append(mmGetPostByID.GetPostByIDMock.callArgs, &mm_params)
	mmGetPostByID.GetPostByIDMock.mutex.Unlock()

	for _, e := range mmGetPostByID.GetPostByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmGetPostByID.GetPostByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPostByID.GetPostByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPostByID.GetPostByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetPostByID.GetPostByIDMock.defaultExpectation.paramPtrs

		mm_got := StorageMockGetPostByIDParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetPostByID.t.Errorf("StorageMock.GetPostByID got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPostByID.GetPostByIDMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmGetPostByID.t.Errorf("StorageMock.GetPostByID got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetPostByID.GetPostByIDMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPostByID.t.Errorf("StorageMock.GetPostByID got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetPostByID.GetPostByIDMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPostByID.GetPostByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPostByID.t.Fatal("No results are set for the StorageMock.GetPostByID")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmGetPostByID.funcGetPostByID != nil {
		return mmGetPostByID.funcGetPostByID(ctx, id)
	}
	mmGetPostByID.t.Fatalf("Unexpected call to StorageMock.GetPostByID. %v %v", ctx, id)
	return
}

// GetPostByIDAfterCounter returns a count of finished StorageMock.GetPostByID invocations
func (mmGetPostByID *StorageMock) GetPostByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostByID.afterGetPostByIDCounter)
}

// GetPostByIDBeforeCounter returns a count of StorageMock.GetPostByID invocations
func (mmGetPostByID *StorageMock) GetPostByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPostByID.beforeGetPostByIDCounter)
}

// Calls returns a list of arguments used in each call to StorageMock.GetPostByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPostByID *mStorageMockGetPostByID) Calls() []*StorageMockGetPostByIDParams {
	mmGetPostByID.mutex.RLock()

	argCopy := make([]*StorageMockGetPostByIDParams, len(mmGetPostByID.callArgs))
	copy(argCopy, mmGetPostByID.callArgs)

	mmGetPostByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetPostByIDDone returns true if the count of the GetPostByID invocations corresponds
// the number of defined expectations
func (m *StorageMock) MinimockGetPostByIDDone() bool {
	if m.GetPostByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetPostByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetPostByIDMock.invocationsDone()
}

// MinimockGetPostByIDInspect logs each unmet expectation
func (m *StorageMock) MinimockGetPostByIDInspect() {
	for _, e := range m.GetPostByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageMock.GetPostByID at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetPostByIDCounter := mm_atomic.LoadUint64(&m.afterGetPostByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetPostByIDMock.defaultExpectation != nil && afterGetPostByIDCounter < 1 {
		if m.GetPostByIDMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageMock.GetPostByID at\n%s", m.GetPostByIDMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageMock.GetPostByID at\n%s with params: %#v", m.GetPostByIDMock.defaultExpectation.expectationOrigins.origin, *m.GetPostByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPostByID != nil && afterGetPostByIDCounter < 1 {
		m.t.Errorf("Expected call to StorageMock.GetPostByID at\n%s", m.funcGetPostByIDOrigin)
	}

	if !m.GetPostByIDMock.invocationsDone() && afterGetPostByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageMock.GetPostByID at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetPostByIDMock.expectedInvocations), m.GetPostByIDMock.expectedInvocationsOrigin, afterGetPostByIDCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateCommentInspect()

			m.MinimockCreatePostInspect()

			m.MinimockGetAllPostsInspect()

			m.MinimockGetCommentsByParentIDInspect()

			m.MinimockGetCommentsByPostIDsInspect()

			m.MinimockGetPostByIDInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateCommentDone() &&
		m.MinimockCreatePostDone() &&
		m.MinimockGetAllPostsDone() &&
		m.MinimockGetCommentsByParentIDDone() &&
		m.MinimockGetCommentsByPostIDsDone() &&
		m.MinimockGetPostByIDDone()
}
